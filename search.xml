<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>23s魂土</title>
    <url>/2021/10/09/23s%E9%AD%82%E5%9C%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>纪念一下签到180天终于做出了23s魂土的阵容，也总结一下云舅阵容的御魂要求。</p>
<p>首先阵容里的式神是： 云外镜，玉藻前（可替换为烬天玉藻前，要求更低），鬼王酒吞童子，薰和童男。其中鬼王酒吞童子的作用是增伤，大妖之力的效果血量每减少1%伤害增加1%，所以对技能并没有要求。这种阵容的思路是在第二回目让式神被大天狗刮死，然后童男献祭复活所有式神，这样输出式神的血量会非常少，直接吃到将近99%的增伤，然后收掉二回目和三回目。</p>
<h5 id="速度要求"><a href="#速度要求" class="headerlink" title="速度要求"></a>速度要求</h5><p>式神的速度要求为:<br><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">158 </span>&gt; 云外镜 &gt; 玉藻前 &gt; <span class="number">156</span> &gt; 童男 &gt; <span class="number">155</span> &gt; 鬼王酒吞童子 &gt; <span class="number">135</span> &gt; 薰</span><br></pre></td></tr></table></figure><br>其中鬼王酒吞童子大于135只是为了最后补一下刀，如果伤害足够的话这个不是强制要求。 童男速度不强制要求小于156，玉藻前和云外镜，但必须小于158，大于155。速度要求的原因是第二回目大天狗的速度是158，要保证第二回合让大天狗第一个行动将式神都刮死，然后童男行动复活，所以童男不能先于大天狗行动，否则童男回合过了无法献祭；黑晴明的速度是155，要保证在黑晴明行动前把第二回目清了。云外镜先于玉藻前，玉藻前先于云外镜的情况御魂数值要求会发生改变，这里不做讨论。</p>
<h4 id="御魂搭配及数值要求"><a href="#御魂搭配及数值要求" class="headerlink" title="御魂搭配及数值要求"></a>御魂搭配及数值要求</h4><div class="table-container">
<table>
<thead>
<tr>
<th>式神</th>
<th>御魂套装</th>
<th>面板要求</th>
</tr>
</thead>
<tbody>
<tr>
<td>云外镜</td>
<td>狂骨鬼灵歌姬</td>
<td>12400&lt;面板&lt;13300</td>
</tr>
<tr>
<td>玉藻前</td>
<td>狂骨荒骷髅</td>
<td>14400&lt;面板</td>
</tr>
<tr>
<td>薰</td>
<td>火灵</td>
<td>26000&lt;生命值</td>
</tr>
</tbody>
</table>
</div>
<p>云外镜玉藻前都要求满暴击，并且输出技能等级要最高。云外镜面板低于12400时无法杀死黑晴明，面板高于13300的时候会杀死雪女，导致玉藻前施放狐火慢1s，当然可以通过锁定堕天来解决这个问题。因为云外镜面板数值要求不高，二号位可以放主属性为速度的御魂。六星二号位速度御魂强化到12级正好只加48速度，让云外镜速度达标。</p>
<p>注意云外镜的面板计算方式为:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">（攻击 + 防御 <span class="emphasis">* 2 ） *</span> 爆伤</span><br></pre></td></tr></table></figure>
<p>附带我的云外镜和玉藻前的面板</p>
<p><img src="/images/云外镜.png" alt="云外镜"><br><img src="/images/大舅.png" alt="玉藻前"></p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>阴阳师</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建hexo参考的资料</title>
    <url>/2021/10/03/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>终于是有了自己的个人博客，本来以为这件事是需要前后端从头到尾自己写，没想到现在有这么多成熟的博客框架，浏览了一圈后选定使用hexo，主要是因为和github配合部署的方案比较成熟，说白了因为对懒人好。<br>整个过程中参考了以下一些资料，感谢各位大佬提供的经验！</p>
<h3 id="视频参考"><a href="#视频参考" class="headerlink" title="视频参考"></a>视频参考</h3><p>主要参考了这位up主的教程： <a href="https://www.bilibili.com/video/BV1mU4y1j72n?p=1">【2021最新版】保姆级Hexo+github搭建个人博客</a> 可谓是真的保姆级了</p>
<h3 id="文字参考"><a href="#文字参考" class="headerlink" title="文字参考"></a>文字参考</h3><p><a href="https://yehansharp.github.io/2019/12/28/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8Hexo%E9%85%8D%E5%90%88Github%E8%BF%9B%E8%A1%8C%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA">Hexo博客系列（一）：使用Hexo配合Github进行静态博客搭建</a></p>
<p><a href="https://github.com/theme-next/hexo-theme-next">Next主题for hexo</a></p>
<p><a href="https://github.com/jaredly/hexo-admin">hexo 管理工具</a></p>
<h3 id="Debug-记录"><a href="#Debug-记录" class="headerlink" title="Debug 记录"></a>Debug 记录</h3><p>在部署到github的时候，有一次更换主题后css就加载不出来了，重新clean deploy了好几次都没解决，参考大量资料有说是github deploy branch的问题，有说是config.yml里root和url的问题，经过我一系列操作后终于解决了：</p>
<ol>
<li>首先github.io目前只支持在主分支上部署，指定分支部署已经不支持了，所以hexo的部署分支一定是master（现在应该叫main了），你的code放到另一个分支上。</li>
<li>config.yml里的url和root填的不对应该会导致css文件拿不到，url如果你用github的话，就填成<code>https://username.github.io/</code>, root就填 <code>/</code>就行。</li>
<li>还是不行的话就清除浏览器cookie。</li>
</ol>
<p>我是通过以上三种操作解决了样式无法加载的问题。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题记录-1</title>
    <url>/2021/10/26/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h5 id="2021-10-26"><a href="#2021-10-26" class="headerlink" title="2021.10.26"></a>2021.10.26</h5><p>LeetCode Curated Algo 170，Array tag</p>
<p><a href="https://leetcode.com/problems/alien-dictionary/">Leetcode 269 Alien Dictionary</a> </p>
<p>不知道为啥alien dictionary被归类到了Array tag，这道题新增了一种corner case，之前的解法是没有考虑到这种情况的，导致来来回回提交了好多遍。</p>
<p>这个题的解法比较简单，就是一个topological sort。难点是理解题意找到构建入度的方法。这个比较的顺序不是在一个单词中，而是要比较两个相邻单词第一个不一样的字母，但要注意新增的corner case为 <code>[&#39;abc&#39;, &#39;ab&#39;]</code>, 这种相邻单词的第一个单词的长度比第二个长，且第一个单词startswith第二个单词。几次提交失败的原因是没考虑到下面几个点：</p>
<ol>
<li>在初始化indegrees和neighbors map的时候要遍历一遍所有word，把所有字母都初始化到。</li>
<li>最后输出的结果长度应该与indegrees的size相等。</li>
<li>在找到一组字母关系后，应该先检查这个关系是否已经被加过了，不能重复加。</li>
<li>corner case的处理，在两个单词作比较之前先检查。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">alienOrder</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="comment"># 没用defaultdict，因为总归要遍历一遍字母</span></span><br><span class="line">        indegree = &#123;&#125;</span><br><span class="line">        neighbors = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">                indegree[char] = <span class="number">0</span></span><br><span class="line">                neighbors[char] = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(words) - <span class="number">1</span>):</span><br><span class="line">            word1 = words[i]</span><br><span class="line">            word2 = words[i+<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># handle corner case </span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(word1) &gt; <span class="built_in">len</span>(word2) <span class="keyword">and</span> word1.startswith(word2):</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">            index = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> index &lt; <span class="built_in">min</span>(<span class="built_in">len</span>(word1), <span class="built_in">len</span>(word2)):</span><br><span class="line">                <span class="keyword">if</span> word1[index] == word2[index]:</span><br><span class="line">                    index += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment">#检查这个关系是否已经加过了，不能重复加</span></span><br><span class="line">                    <span class="keyword">if</span> word2[index] <span class="keyword">not</span> <span class="keyword">in</span> neighbors[word1[index]]:</span><br><span class="line">                        indegree[word2[index]] += <span class="number">1</span></span><br><span class="line">                        neighbors[word1[index]].add(word2[index])</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="comment">#bfs</span></span><br><span class="line">        starts = []</span><br><span class="line">        <span class="keyword">for</span> key,value <span class="keyword">in</span> indegree.items():</span><br><span class="line">            <span class="keyword">if</span> value == <span class="number">0</span>:</span><br><span class="line">                starts.append(key)</span><br><span class="line">        queue = deque(starts)</span><br><span class="line">        result = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            current = queue.popleft()</span><br><span class="line">            result += current</span><br><span class="line">            <span class="keyword">for</span> neighbor <span class="keyword">in</span> neighbors[current]:</span><br><span class="line">                indegree[neighbor] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> indegree[neighbor] == <span class="number">0</span>:</span><br><span class="line">                    queue.append(neighbor)</span><br><span class="line">        <span class="comment">#结果检查            </span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(result) != <span class="built_in">len</span>(indegree):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">            </span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.com/problems/binary-search/">Leetcode 704 Binary Search</a></p>
<p>连二分都写不好了。。。</p>
<p>对于边界条件的限定和left right坐标的移位，主要是考虑区间的性质，是左闭右闭还是左闭右开。当左闭右闭的时候，left == right 是有意义的； 当左闭右开的时候， left == right没有意义，所以左闭右闭的循环条件为 left &lt;= right， 而左闭右开为left &lt; right。</p>
<p>至于右边是否为闭则取决于right的值，如果是length-1那么就是闭的，可以取到且值有意义；如果是length那就是开区间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#左闭右闭</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            middle = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="comment">#取值的时候取middle+1或-1，是因为middle必不可能为target，下次寻找直接跳过middle也可以遍历所有值</span></span><br><span class="line">            <span class="keyword">if</span> nums[middle] &lt; target:</span><br><span class="line">                left = middle + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[middle] &gt; target:</span><br><span class="line">                right = middle - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> middle</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="comment">#right = len(nums)，nums[right]不会被取到，所以right = mid就保证下次查询不会遗漏，如果right = mid -1那么mid -1这个可能值就被排除了</span></span><br><span class="line">        left,right  =<span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.com/problems/employee-free-time/">Leetcode 759 Employee free time</a></p>
<p>本质就是一个merge intervals, 如果用array把所有的intervals放一起然后sort merge的话时间复杂度就是 O(nlogn)。 因为这个题里每个employee的intervals都是有序的，所以可以用merge k sorted interval 来降低时间复杂度，即使用priorityQueue。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">employeeFreeTime</span><span class="params">(List&lt;List&lt;Interval&gt;&gt; schedule)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// pq里放的是坐标，index[0]是第几个employee，index[1]是他的第几个interval</span></span><br><span class="line">        <span class="comment">// 排序还是按照时间最早开始</span></span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b) -&gt; schedule.get(a[<span class="number">0</span>]).get(a[<span class="number">1</span>]).start - schedule.get(b[<span class="number">0</span>]).get(b[<span class="number">1</span>]).start);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; schedule.size(); i++) &#123;</span><br><span class="line">            pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,<span class="number">0</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Interval&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> start = schedule.get(pq.peek()[<span class="number">0</span>]).get(pq.peek()[<span class="number">1</span>]).end;</span><br><span class="line">        <span class="comment">// merge k sorted intervals</span></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] index = pq.poll();</span><br><span class="line">            Interval interval = schedule.get(index[<span class="number">0</span>]).get(index[<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 取merged intervals的互补intervals</span></span><br><span class="line">            <span class="keyword">if</span> (start &lt; interval.start) &#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> Interval(start, interval.start));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 取next max</span></span><br><span class="line">            start = interval.end &gt; start ? interval.end : start;</span><br><span class="line">            <span class="comment">// 判断是否将这个employee的next interval加进来，有就加</span></span><br><span class="line">            <span class="keyword">if</span> (schedule.get(index[<span class="number">0</span>]).size() &gt; index[<span class="number">1</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">                pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;index[<span class="number">0</span>], index[<span class="number">1</span>] + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>merge k sorted 的写法</p>
<p>建立一个大小为k的priorityqueue, 将开头的k个元素放进去，依次往外poll。如果是简单的merge elements就直接接上就行，然后将下一个元素放进去；如果是interval就要用到merge interval的方法，即比较区间结尾的大小。在放下一个元素的时候要注意检查是否存在。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b) -&gt; a.val - b.val);</span><br><span class="line">        <span class="keyword">if</span> (lists.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (ListNode node : lists) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pq.offer(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode head = dummy;</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            ListNode current = pq.poll();</span><br><span class="line">            head.next = <span class="keyword">new</span> ListNode(current.val);</span><br><span class="line">            head = head.next;</span><br><span class="line">            current = current.next;</span><br><span class="line">            <span class="keyword">if</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pq.offer(current);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习 leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo美化记录</title>
    <url>/2021/10/04/hexo%E7%BE%8E%E5%8C%96%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="增加文章结尾自定义文字"><a href="#增加文章结尾自定义文字" class="headerlink" title="增加文章结尾自定义文字"></a>增加文章结尾自定义文字</h4><p>在 <code>hexo/themes/next/layout/_marco</code> 下新建文件<code>passage-end-tag.swig</code> 并在其中保存以下内容<br><figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> not is_index %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;text-align:center;color: #ccc;font-size:14px;&quot;</span>&gt;</span></span><span class="template-variable">&#123;&#123;theme.passage_end_tag.content&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><br>修改<code>hexo/themes/next/layout/_marco/post.swig</code>， 在<code>POST BODY</code>代码块后，<code>POST FOOTER</code>代码块前加入<br><figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> not is_index and theme.passage_end_tag.enabled %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">  </span><span class="template-tag">&#123;% <span class="name"><span class="name">include</span></span> &#x27;passage-end-tag.swig&#x27; %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span></span><br></pre></td></tr></table></figure><br>最后修改主题配置文件<code>themes/next/_config.yml</code>新加以下内容, <code>content</code>是你自定义的结尾文字<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文章末尾添加“本文结束”标记</span></span><br><span class="line"><span class="attr">passage_end_tag:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">content:</span> <span class="string">你的自定义结尾文字</span></span><br></pre></td></tr></table></figure></p>
<h4 id="启用canvas-nest"><a href="#启用canvas-nest" class="headerlink" title="启用canvas-nest"></a>启用canvas-nest</h4><p>最新版的Next已经不再集成nest，但是我尝试使用最新的启用nest的指导方法并没有成功启用nest，最后还是用了老方法将nest源文件加在Next的lib中。<br>在Next文件夹中将源文件拷贝下来：<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/theme-next/</span>theme-<span class="keyword">next</span>-canvas-nest source<span class="regexp">/lib/</span>canvas-nest</span><br></pre></td></tr></table></figure><br>并在主题配置文件<code>themes/next/_config.yml</code>中增加<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#canvas nest </span></span><br><span class="line"><span class="attr">canvas_nest:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>    <span class="comment">#开启canvas</span></span><br><span class="line">  <span class="attr">onmobile:</span> <span class="literal">true</span> <span class="comment"># 是否在移动站开启canvas</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&#x27;34,34,34&#x27;</span> <span class="comment"># 颜色值</span></span><br><span class="line">  <span class="attr">opacity:</span> <span class="number">0.5</span> <span class="comment"># 数值 0~1 ，线条透明度</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">-1</span> <span class="comment"># 背景叠层大小，-1代表放在文章的后面</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">200</span> <span class="comment"># 线条数量</span></span><br></pre></td></tr></table></figure></p>
<h4 id="增加音乐播放器"><a href="#增加音乐播放器" class="headerlink" title="增加音乐播放器"></a>增加音乐播放器</h4><p>使用hexo-aplayer为博客增加背景音乐，具体方式参考</p>
<blockquote>
<p><a href="https://leezhiy.github.io/2020/04/11/2020-04-11-Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%EF%BC%88%E6%B7%BB%E5%8A%A0%E7%BD%91%E9%A1%B5%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%EF%BC%89/">Hexo+Next 搭建个人博客 （添加网页音乐播放器）</a></p>
</blockquote>
<p>采用文中第二种方法。注意作者所说的<code>hexo/scripts/plugins.js</code>并不存在，需要自己新建。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
