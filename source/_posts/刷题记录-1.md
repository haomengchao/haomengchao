title: 刷题记录-1
author: Mengchao Hao
tags:
  - 学习
  - Leetcode
categories:
  - 学习
date: 2021-10-26 06:51:00
---
#### Array tag

##### 2021.10.26

[Leetcode 269 Alien Dictionary](https://leetcode.com/problems/alien-dictionary/) 

不知道为啥alien dictionary被归类到了Array tag，这道题新增了一种corner case，之前的解法是没有考虑到这种情况的，导致来来回回提交了好多遍。

这个题的解法比较简单，就是一个topological sort。难点是理解题意找到构建入度的方法。这个比较的顺序不是在一个单词中，而是要比较两个相邻单词第一个不一样的字母，但要注意新增的corner case为 `['abc', 'ab']`, 这种相邻单词的第一个单词的长度比第二个长，且第一个单词startswith第二个单词。几次提交失败的原因是没考虑到下面几个点：
1. 在初始化indegrees和neighbors map的时候要遍历一遍所有word，把所有字母都初始化到。
2. 最后输出的结果长度应该与indegrees的size相等。
3. 在找到一组字母关系后，应该先检查这个关系是否已经被加过了，不能重复加。
4. corner case的处理，在两个单词作比较之前先检查。

代码如下：

```python
class Solution:
    def alienOrder(self, words: List[str]) -> str:
        # 没用defaultdict，因为总归要遍历一遍字母
        indegree = {}
        neighbors = {}
        for word in words:
            for char in word:
                indegree[char] = 0
                neighbors[char] = set()

        for i in range(len(words) - 1):
            word1 = words[i]
            word2 = words[i+1]
            # handle corner case 
            if len(word1) > len(word2) and word1.startswith(word2):
                return ""
            index = 0
            while index < min(len(word1), len(word2)):
                if word1[index] == word2[index]:
                    index += 1
                else:
                    #检查这个关系是否已经加过了，不能重复加
                    if word2[index] not in neighbors[word1[index]]:
                        indegree[word2[index]] += 1
                        neighbors[word1[index]].add(word2[index])
                    break
        #bfs
        starts = []
        for key,value in indegree.items():
            if value == 0:
                starts.append(key)
        queue = deque(starts)
        result = ""
        while queue:
            current = queue.popleft()
            result += current
            for neighbor in neighbors[current]:
                indegree[neighbor] -= 1
                if indegree[neighbor] == 0:
                    queue.append(neighbor)
        #结果检查            
        if len(result) != len(indegree):
            return ""
        return result
            
        
```


[Leetcode 704 Binary Search](https://leetcode.com/problems/binary-search/)

连二分都写不好了。。。

对于边界条件的限定和left right坐标的移位，主要是考虑区间的性质，是左闭右闭还是左闭右开。当左闭右闭的时候，left == right 是有意义的； 当左闭右开的时候， left == right没有意义，所以左闭右闭的循环条件为 left <= right， 而左闭右开为left < right。

至于右边是否为闭则取决于right的值，如果是length-1那么就是闭的，可以取到且值有意义；如果是length那就是开区间。

```python

#左闭右闭
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        
        while left <= right:
            middle = (left + right) // 2
        #取值的时候取middle+1或-1，是因为middle必不可能为target，下次寻找直接跳过middle也可以遍历所有值
            if nums[middle] < target:
                left = middle + 1
            elif nums[middle] > target:
                right = middle - 1
            else:
                return middle
        return -1

```

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
    #right = len(nums)，nums[right]不会被取到，所以right = mid就保证下次查询不会遗漏，如果right = mid -1那么mid -1这个可能值就被排除了
        left,right  =0, len(nums)
        while left < right:
            mid = (left + right) // 2
            if nums[mid] < target:
                left = mid+1
            elif nums[mid] > target:
                right = mid
            else:
                return mid
        return -1
```



[Leetcode 759 Employee free time](https://leetcode.com/problems/employee-free-time/)


本质就是一个merge intervals, 如果用array把所有的intervals放一起然后sort merge的话时间复杂度就是 O(nlogn)。 因为这个题里每个employee的intervals都是有序的，所以可以用merge k sorted interval 来降低时间复杂度，即使用priorityQueue。

```java
class Solution {
    public List<Interval> employeeFreeTime(List<List<Interval>> schedule) {
        // pq里放的是坐标，index[0]是第几个employee，index[1]是他的第几个interval
        // 排序还是按照时间最早开始
        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> schedule.get(a[0]).get(a[1]).start - schedule.get(b[0]).get(b[1]).start);
        for (int i = 0; i < schedule.size(); i++) {
            pq.offer(new int[]{i,0});
        }
        List<Interval> result = new ArrayList<>();
        int start = schedule.get(pq.peek()[0]).get(pq.peek()[1]).end;
        // merge k sorted intervals
        while (!pq.isEmpty()) {
            int[] index = pq.poll();
            Interval interval = schedule.get(index[0]).get(index[1]);
            // 取merged intervals的互补intervals
            if (start < interval.start) {
                result.add(new Interval(start, interval.start));
            }
            // 取next max
            start = interval.end > start ? interval.end : start;
            // 判断是否将这个employee的next interval加进来，有就加
            if (schedule.get(index[0]).size() > index[1] + 1) {
                pq.offer(new int[]{index[0], index[1] + 1});
            } 
        }
        return result;
    }
}
```

merge k sorted 的写法

建立一个大小为k的priorityqueue, 将开头的k个元素放进去，依次往外poll。如果是简单的merge elements就直接接上就行，然后将下一个元素放进去；如果是interval就要用到merge interval的方法，即比较区间结尾的大小。在放下一个元素的时候要注意检查是否存在。

```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        PriorityQueue<ListNode> pq = new PriorityQueue<>((a,b) -> a.val - b.val);
        if (lists.length == 0) {
            return null;
        }
        for (ListNode node : lists) {
            if (node != null) {
                pq.offer(node);
            }
        }
        ListNode dummy = new ListNode(0);
        ListNode head = dummy;
        while (!pq.isEmpty()) {
            ListNode current = pq.poll();
            head.next = new ListNode(current.val);
            head = head.next;
            current = current.next;
            if (current != null) {
                pq.offer(current);
            }
        }
        return dummy.next;
    }
}
```


##### 10.27

[Leetcode 4. Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/)


discussion高赞讲的真不错[Share-my-O(log(min(mn)))-solution-with-explanation]( https://leetcode.com/problems/median-of-two-sorted-arrays/discuss/2481/Share-my-O%28log%28min%28mn%29%29%29-solution-with-explanation )

```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        m = len(nums1)
        n = len(nums2)
        if m > n:
            m, n, nums1, nums2 = n, m, nums2, nums1
        i_left = 0
        i_right = m
        #要整除
        mid = (m + n + 1) // 2
        while i_left <= i_right:
        #要整除
            i = (i_left + i_right) // 2 
            j = mid - i
            
            if i < m and nums2[j-1] > nums1[i]:
                i_left = i + 1
            elif i > 0 and nums1[i-1] > nums2[j]:
                i_right = i - 1 
            else:
                if i == 0:
                    max_left = nums2[j-1]
                elif j == 0:
                    max_left = nums1[i-1]
                else:
                    max_left = max(nums1[i-1], nums2[j-1])
                if (m + n) % 2 == 1:
                    return max_left
                if i == m:
                    min_right = nums2[j]
                elif j ==n:
                    min_right = nums1[i]
                else:
                    min_right = min(nums1[i], nums2[j])
                return (max_left + min_right) / 2.0
        
        
```

[Leetcode 56. Merge Intervals](https://leetcode.com/problems/merge-intervals/)

merge interval要注意最后一个interval要加到结果中去

```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals = sorted(intervals, key = lambda x:x[0])
        result = []
        index = 1
        current_interval = intervals[0]
        while index < len(intervals):
            next_interval = intervals[index]
            if next_interval[0] > current_interval[1]:
                result.append(current_interval)
                current_interval = next_interval
            else:
                current_interval[1] = max(current_interval[1], next_interval[1])
            index += 1
        #最后一个interval要加进去
        result.append(current_interval)
        return result
```

[Leetcode 53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)


maximu subarray的问题，要注意看问题到底是要求必须选一个数还是可以不选。如果不选就完全是[Kadane's algorithm](https://en.wikipedia.org/wiki/Maximum_subarray_problem)。原则就是当max_subarray_sum[i-1] < 0时，舍弃这段subarray sum。因为一个小于0的数加任何数都比这个数字小。但是对于必须选一个数的要求时，将前面的subarray sum舍弃后新的subarray sum就是当前这个数字。即 current_sum[i] = max(current_sum[i-1],0) + nums[i]

```python
    def maxSubArray(self, nums: List[int]) -> int:
        # 到坐标为j时的最大sub_sum = max(sub_sum[j-1], 0)
        # 只要前面的sub array sum是正数，就要；如果不是，就舍弃全部sub sum
        current_sum = nums[0]
        max_sum = nums[0]
        for i in range(1,len(nums)):
            current_sum = max(current_sum, 0) + nums[i]
            max_sum = max(max_sum, current_sum)
        return max_sum
```

如果不要求必须选一个数字的话，那么current_sum至少是一个大于等于0的数字，因为只要subsum小于0我们就舍弃重新开始选择数字，那么有subarray_sum[i] = subarray_sum[i-1] + nums[i] >= nums[i]。 如果subarray_sum[i] 是小于零的就直接舍弃

```python
    def maxSubArray(self, nums: List[int]) -> int:
        current_sum = 0
        max_sum = 0
        for i in range(len(nums)):
            current_sum = max(current_sum + nums[i], 0)
            max_sum = max(max_sum, current_sum)
        return max_sum
```


[Leetcode 560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)

subarray sum 一开始会想到prefix_sum来解，但是没必要将prefix_sum都记录下来。这道题本质是prefix_sum + two sum， 因为subarray_sum[i,j] = subarray_sum[j] - subarray_sum[i-1] = k。然后我们已知的是subarray_sum[j]，那么map里的key应该是subarray_sum[i-1] = subarray_sum[j] - k。另外值相同的subarray_sum[i-1]可能有多个位置，所以map里记录的是当前值发生的次数，在计算可能性时不是简单的加1，而是加上这个count。

```python
import collections
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        current_sum = 0
        count_map = defaultdict(int)
        count = 0
        #一定要加上prefix_sum = 0 的情况
       	 count_map[0] = 1
        for i in range(len(nums)):
        #current_sum可以理解为subarray_sum[j] (设j > i)
            current_sum += nums[i]
            #two sum, 找互补
            if current_sum - k in count_map:
                count += count_map[current_sum - k]
            # 在下一个i开始后，这个current_sum(subarray_sum[j])就会成为下一个等式中的互补项，所以要把它加进map中，或更新count
            count_map[current_sum] = count_map[current_sum] + 1
        return count 
```


##### 10.28

[Leetcode 31. Next Permutation
](https://leetcode.com/problems/next-permutation/)

参考[Next Permutation](https://www.nayuki.io/page/next-lexicographical-permutation-algorithm)

算法为：从后向前找到第一个非递增数，这个非递增数前一个数是要放到后面的数字。再从后向前找到第一个不小于这个数字的数，然后两数替换，将后半部分反转。

```python
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        if len(nums) == 1:
            return
        left_index = len(nums) - 1
        right_index = len(nums) - 1
        while left_index > 0:
            if nums[left_index - 1] >= nums[left_index]:
                left_index -= 1
            else:
                break
        if left_index == 0:
            nums.reverse()
            return 
        left_index -= 1
        while right_index > left_index:
            if nums[right_index] <= nums[left_index]:
                right_index -= 1
            else:
                break
        nums[left_index], nums[right_index] = nums[right_index], nums[left_index]
        i = left_index + 1
        j = len(nums) - 1
        while i <= j:
            nums[i], nums[j] = nums[j], nums[i]
            i += 1
            j -= 1
            
```

优化： 找到第一个不小于pivot数的时候可以用binary search


[Leetcode 54. Spiral Matrix](https://leetcode.com/problems/spiral-matrix/)

注意只有一行或者一列的情况，在从右往左扫和从下往上扫的时候要检查这行这列是不是已经扫过了，避免重复

```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        left_bound = 0
        right_bound = len(matrix[0]) -1
        upper_bound = 0
        lower_bound = len(matrix) -1 
        result = []
        while left_bound <= right_bound and upper_bound <= lower_bound:
            for i in range(left_bound, right_bound + 1):
                result.append(matrix[upper_bound][i])
            upper_bound += 1
            for i in range(upper_bound, lower_bound + 1):
                result.append(matrix[i][right_bound])
            right_bound -= 1
            #检查是否扫过了，从右往左的时候
            if upper_bound <= lower_bound:
                for i in range(right_bound, left_bound-1, -1):
                    result.append(matrix[lower_bound][i])
                lower_bound -= 1
            #从下往上
            if left_bound <= right_bound:
                for i in range(lower_bound, upper_bound - 1, - 1):
                    result.append(matrix[i][left_bound])
                left_bound += 1
        return result
```

[Leetcode 239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) 

sliding window max/min 问题一般是单调队列。不能用单调栈是因为如果数组是一个递减的，那么后面的那些更小的数字是有可能成为max的，所以不能单纯的不管它们。而单调栈会忽略这些数字。如果数组是递增的，那么单调队列和单调栈的作用一样。当窗口中有一个较大数字且之后的数字是递增的，那么窗口中其他的小数字必不可能成为最大，所以不需要关心当窗口滑过小的数字。

1. 当新进入窗口的数字小于之前的最大值，将其加到队列末尾
2. 当新进入窗口的数字大于之前的最大值，将队列中所有小于这个数字的数pop out
3. 当数字离开窗口时，需要check这个数字是不是之前队列的最大值，如果是的话队列要popleft

```python
import collections
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        q = deque([])
        result = []
        if k == len(nums):
            return [max(nums)]
        #新加数字，对应2
        for i in range(k):
            while q and nums[i] > nums[q[-1]]:
                q.pop()
            q.append(i)
            
        for i in range(0,len(nums) - k + 1):
        #数字离开窗口，对应3
            while q and q[0] < i:
                q.popleft()
            #新数字加入 对应2
            right = i + k - 1
            while q and nums[right] > nums[q[-1]]:
                q.pop()
            # 对应1
            q.append(right)
            result.append(nums[q[0]])
        return result
```

##### 11.15

[Leetcode 710. Random Pick with Blacklist](https://leetcode.com/problems/random-pick-with-blacklist/)

这种要求O(1)生成随机数的问题，底层数据结构一定是hashmap + array。只有array可以通过O(1)时间进行random索引。但前提是这个array必须是紧凑的，而黑名单的数字分布在array各处，所以要通过index mapping把这些数字map到array的结尾，这样array的前部分就都是有效的数字且紧凑。这个题并不真正需要一个array来装数字，因为n是紧凑的。


```python
class Solution:

    def __init__(self, n: int, blacklist: List[int]):
        self.mapping = {}
        for num in blacklist:
            self.mapping[num] = -1
        self.size = n - len(blacklist)
        last = n - 1
        for num in blacklist:
        #黑名单的数字本来就在末尾，不需要移动
            if num >=self.size:
                continue
            #末尾这个数字是黑名单的数字，也不能移动
            while last in self.mapping:
                last -= 1
            #合理的移动
            self.mapping[num] = last
            last -= 1
        
    def pick(self) -> int:
        num = random.randint(0,self.size-1)
        if num in self.mapping:
            return self.mapping[num]
        return num

```

[Leetcode 316. Remove Duplicate Letters](https://leetcode.com/problems/remove-duplicate-letters/)

字符串去重，并且保证最后字符串字典序最小。如果仅仅是保证字符串去重的话，可以通过一个stack来做。遇到新字符就加进去，stack已经有的字符就不加。但这样并不能保证最后的字典序最小，所以要使用单调栈来保存一个字典序尽可能小的序列。首先容易想到如果新来的字符序比较小的话，就把前面序大的pop出去。但是如果无脑pop的话最后剩下的字符串可能不是全集，所以在pop的时候要增加限制条件。如果这个被pop的字符后面还会出现，那么它被pop出去就是安全的，后面还会再进来。所以我们要记录字符的count，只有在count>0的时候才pop。另一点需要考虑的是重复字母，已经在栈里的字母就不用再进行单调栈操作了，直接更新count然后处理下一个字母就行了。

```python
from collections import defaultdict
class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        count = defaultdict(int)
        in_stack = defaultdict(bool)
        for ch in s:
            count[ch] += 1
        stack = []
        index = 0
        while index < len(s):
            current = s[index]
            #只有这个字母不在栈里时才pop其他字母
            if not in_stack[current]:
                #保证之后还会再遇到这个被pop出去的字母，所以count要>0
                while len(stack) != 0 and stack[-1] > current and count[stack[-1]] > 0:
                    removed = stack.pop()
                    #被pop出去后更新是否在栈里的状态
                    in_stack[removed] = False
                stack.append(current)
            #处理完一个字母，之后这个字母的出现次数就少一次
            count[current] -= 1
            in_stack[current] = True
            index += 1
        return "".join(stack)
```