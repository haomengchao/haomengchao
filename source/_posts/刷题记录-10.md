title: 刷题记录-10
author: Mengchao Hao
date: 2021-12-01 21:17:05
tags:
---
#### 难题

##### i,j区间问题

[Leetcode 327. Count of Range Sum](https://leetcode.com/problems/count-of-range-sum/)

naive的做法是O(n2),遍历每个sub array sum然后判断其是否在范围内，优化做法是使用merge sort。因为merge sort在对两个区间进行merge之前，这两个区间是有序并且右边区间的所有元素在原数组的顺序都是大于左边数组的所有元素的。因为subarray sum = prefix_sum[j] - prefix_sum[i],至于j和i具体是什么值这道题不关心，但是j必须得大于i，而merge sort可以保证这一点。所以可以通过在merge之前，计算出复合条件的i，j 的位置。具体做法是，让左边区间的数字当成prefix_sum[i],在右边区间找prefix_sum[j]。j的上下界必须满足prefix_sum[j]-prefix_sum[i]在lower和upper之间。左边区间和右边区间里各自的可能值在属于他们的那一轮merge sort已经计算过了。至于这个额外部分的时间复杂度，因为j总是在右半区间里找它的上下界，每次merge之前j是至多走mid->end个元素，即可遍历所有可能的k（因为针对不同的k，j是单调递增的），所以额外部分的时间复杂度是O(n)的，整体算法的时间复杂度还是O(nlogn)

```python
class Solution:
    def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:
        prefix_sum = [0]
        for num in nums:
            prefix_sum.append(prefix_sum[-1] + num)
        return self.mergeSort(prefix_sum, lower, upper, 0, len(prefix_sum)-1)
    def mergeSort(self, prefix_sum, lower, upper, start, end):
        if start >=end:
            return 0
        mid = start + (end - start) // 2
        count = self.mergeSort(prefix_sum, lower, upper, start, mid) + self.mergeSort( prefix_sum, lower, upper, mid + 1, end)
        #i, j 是找符合条件的j的区间范围， 这个j指prefix_sum[j]的j
        i = mid + 1
        j = mid + 1
        #[start, mid]
        for k in range(start, mid+1):
            while i <= end and prefix_sum[i] - prefix_sum[k] < lower:
                i += 1
            while j <= end and  prefix_sum[j] - prefix_sum[k] <=upper:
                j += 1
            #i是符合条件的第一个，j是不符合条件的第一个，即符合条件的最后一个+1
            #所以j-i不用再+1
            count += j - i
        self.merge(prefix_sum, start, mid, end)
        return count
    def merge(self, prefix_sum, start,mid, end):
            helper = prefix_sum[start : end+1]
            i = start 
            j = mid + 1
            index = start
            while i <= mid and j <= end:
                if helper[i -start] <= helper[j - start]:
                    prefix_sum[index] = helper[i - start]
                    i += 1
                else:
                    prefix_sum[index] = helper[j - start]
                    j += 1
                index += 1
            while i <= mid:
                prefix_sum[index] = helper[i-start]
                i += 1
                index += 1
```