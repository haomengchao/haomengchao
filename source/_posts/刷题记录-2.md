title: 刷题记录-2
author: Mengchao Hao
tags:
  - 学习
  - leetcode
categories:
  - 学习
date: 2021-10-30 10:33:00
---
#### BFS

##### 10.30

[Leetcode 752. Open the Lock](https://leetcode.com/problems/open-the-lock/)

常规bfs题，这里主要记录一下双向BFS怎么做。首先queue换成set，方便快速查询是否有交集，即能否到达结果。其次拓展不是同时拓展的，通过将两个set对倒避免重复代码。但这种情况下注意，将元素加到visited set的时机必须是这个元素被判断过后，如果提前加进visited的话两个set永远不可能有交集。

```python
import collections
class Solution:
    def openLock(self, deadends: List[str], target: str) -> int:
        visited = set()
        deads = set()
        for deadend in deadends:
            deads.add(deadend)
        start = "0000"
        end = target
        if start in deads:
            return -1
        q_1 = set()
        q_2 = set()
        q_1.add(start)
        q_2.add(target)
        step = 0
        while q_1 and q_2:
            temp = set()
            for current in q_1:
                if current in q_2:
                    return step
                #必须在单个元素判断结束后将其加到visited里，不能提前加
                #因为双向bfs的目的是判断是否有交集，如果单个元素在真正visited之前加入visited后
                #那这个元素必不可能被加到temp中，永远不可能有交集
                visited.add(current)
                next_ups = self.rotate_up(current)
                next_downs = self.rotate_down(current)
                for next_up in next_ups:
                    if next_up not in visited and next_up not in deads:
                        temp.add(next_up)
                for next_down in next_downs:
                    if next_down not in visited and next_down not in deads:
                        temp.add(next_down)
            step += 1
            q_1 = q_2.copy()
            q_2 = temp.copy()
        return -1
        
    def rotate_up(self, s):
        list_s = list(s)
        result = []
        for i in range(len(list_s)):
            number = int(list_s[i])
            new_number = (number + 1) % 10
            new_list_s = list_s[:i] + [str(new_number)] + list_s[i+1:]
            result.append("".join(new_list_s))
        return result
    
    def rotate_down(self, s):
        list_s = list(s)
        result = []
        for i in range(len(list_s)):
            number = int(list_s[i])
            new_number = (number - 1) % 10
            new_list_s = list_s[:i] + [str(new_number)] + list_s[i+1:]
            result.append("".join(new_list_s))
        return result
```