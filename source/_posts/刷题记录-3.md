title: 刷题记录-3
author: Mengchao Hao
tags:
  - 学习
  - leetcode
categories:
  - 学习
date: 2021-10-31 10:52:00
---
#### LinkedList

##### 10.31

[Leetcode 160. Intersection of Two Linked Lists](https://leetcode.com/problems/intersection-of-two-linked-lists/)

L1非公共长度m，L2非公共长度n，两者公共长度为k。L1走完开始走L2，L2走完开始走L1，当两者走 m+k+n次后正好在相交点相遇。注意判断条件不能是p1或者p2.next是None，需要让这两个节点都走到null上一次，这样可以handle 两者没有交叉的情况。

```python

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        p_1 = headA
        p_2 = headB
        
        while p_1 != p_2:
            if p_1 is None:
                p_1 = headB
            else:
                p_1 = p_1.next
            if p_2 is None:
                p_2 = headA
            else:
                p_2 = p_2.next
        return p_1
```


[Leetcode 19. Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)

找到一个链表的倒数第k个node，设这个list长为n，那么先让fast指针走k步，再让slow和fast一块走完剩下的（n-k），即fast走到null，那么这时候slow所指的位置就是倒数第k个。因为找到倒数第k个需要找到正数第n-k+1个，即需要走n-k步。从正数第k个走到末尾null上正好是n-k步。
删除第k个，就要找到倒数第k+1个。但是当k=length的时候这个倒数k+1是不存在的null，所以需要加一个dummy head来避免null pointer。注意在一个list的头部加dummy是不影响找倒数的，因为倒数的位置并没有发生改变，所以针对一个没有dummy head的list的findNFromEnd是可以被有dummy head 的list使用并且得到正确结果的。所以代码如下：
```python
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        dummy = ListNode()
        dummy.next = head
        prev = self.findNFromEnd(dummy, n+1)
        prev.next = prev.next.next
        return dummy.next
    def findNFromEnd(self, head, n):
        fast = head
        for _ in range(n):
            fast = fast.next
        slow = head
        while fast is not None:
            fast = fast.next
            slow = slow.next
        return slow
```
如果不想搞这么复杂，就可以稍微改一下findNFromEnd的过程。找倒数第n+1个，则可以找倒数第n个但是让slow指针少走一步，少走一步可以通过改变fast到头的判断方式,即fast==null 改为fast.next==null。
```python
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        fast, slow = head, head
        for _ in range(n): fast = fast.next
        if not fast: return head.next
        while fast.next: fast, slow = fast.next, slow.next
        slow.next = slow.next.next
        return head
```


##### 11.3
Reverse linked list问题

[Leetcode 206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)

最基本的reverse。两种做法: iteratively or recursively。 iter的做法思想很直白，就记录当前和prev node，挨个反转就行了，最后prev node就是新head。 recursive的思想是分为子问题，我反转链表可以简化为反转head.next，然后把原来的head放到new tail的下一个去。需要注意的是，原来的head.next会翻转成子问题的tail，所以并不需要返回tail，只需要new head就行

```python
#iteratively做法
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        prev = None
        current = head
        while current:
            next_temp = current.next
            current.next = prev
            prev = current
            current = next_temp
        return prev
#recursively 做法
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head is None:
            return head
        if head.next is None:
            return head
        last = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return last
```
[Leetcode 92. Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/)

反转一个链表的部分，同样也是有两种做法。iteratively的思想是，找到翻转的head，然后把head后面直到翻转的最后一个node一个一个背到自己身后去，总共背（right - left） 次就完成了。recursively的思想是，对于head的[left,right]的翻转问题可以简化为对于head.next的[left - 1, right - 1]的子问题，当left - 1 == 1的时候问题就简化为了翻转前k个node。
但是iteratively的空间复杂度是O(1),而recursively因为有函数栈所以空间复杂度是O(n)

```python
#iter
class Solution:
    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:
        dummy = ListNode()
        dummy.next = head
        pre = dummy
        current = dummy.next
        for i in range(1,left):
            pre = pre.next
            current = current.next
            
        #prev 是翻转部分的前一个node，是不动的
        #current是翻转部分的第一个node，它会往后移动，并且把遇到的node都背到身后去
        #tmp就是要被背的node
        for i in range(right - left):
            tmp = current.next
            current.next = current.next.next
            #tmp会成为新的head，所以tmp的next一定是prev的next，prev的next是之前的head
            tmp.next = pre.next
            pre.next = tmp
        return dummy.next
#recur
class Solution:
    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:
        if left == 1:
            result, _ = self.reverse(head, right)
            return result
        last = self.reverseBetween(head.next, left-1, right-1)
        head.next = last
        return head
    def reverse(self, head, n):
        if n == 1:
            successor = head.next
            return head, successor
        #successor是没有被翻转的第一个node
        #last 是new head
        last,successor = self.reverse(head.next, n - 1)
        head.next.next = head
        head.next = successor
        return last, successor
```

[Leetcode 25. Reverse Nodes in k-Group](https://leetcode.com/problems/reverse-nodes-in-k-group/)

k个一组来翻转，也可以分成子问题来解决。相当于翻转前k个，然后连接上后面翻转的结果就行了。基本情况是node个数小于k的时候不翻转。所以这个问题就需要reverseK(head,k)。
iteratively的做法是分部分来reverse。用jump记录reverse部分前一个node，l和r是这次reverse的边界，r其实为下一个reverse部分的head。所以在初始化prev的时候让prev = r正好将前部分的head翻转后与下一个部分的head连起来。每次翻转结束后l==r。当都翻转完了后最后一次的count==0，所以会直接return。如果对于剩余部分count不足k的情况，也会直接return。


```python
#iteratively
class Solution:
    def reverseKGroup(self, head, k):
        # Dummy node initialization
        dummy = jump = ListNode(-1)
        dummy.next = l = r = head
        
        while True:
            count = 0
            while r and count < k:
                count += 1
                r = r.next
            if count == k:
                pre, cur = r, l
                for _ in range(k):
                    temp = cur.next
                    cur.next = pre
                    pre = cur
                    cur = temp
                jump.next = pre
                jump = l
                l = r
            else:
                return dummy.next
#recursively
class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        a = head
        b = head
        for i in range(k):
            #先判断，再移动，这样不会遗漏k == length的情况
            if b is None:
                return head
            b = b.next
        new_head = self.reverseFromStartToEnd(a, b)
        head.next = self.reverseKGroup(b, k)
        return new_head
    def reverseFromStartToEnd(self, start, end):
        prev = None
        current = start
        while current != end:
            next_node = current.next
            current.next = prev
            prev = current
            current = next_node
        return prev
```