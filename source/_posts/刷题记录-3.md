title: 刷题记录-3
author: Mengchao Hao
tags:
  - 学习
  - leetcode
categories:
  - 学习
date: 2021-10-31 10:52:00
---
#### LinkedList

##### 10.31

[Leetcode 160. Intersection of Two Linked Lists](https://leetcode.com/problems/intersection-of-two-linked-lists/)

L1非公共长度m，L2非公共长度n，两者公共长度为k。L1走完开始走L2，L2走完开始走L1，当两者走 m+k+n次后正好在相交点相遇。注意判断条件不能是p1或者p2.next是None，需要让这两个节点都走到null上一次，这样可以handle 两者没有交叉的情况。

```python

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        p_1 = headA
        p_2 = headB
        
        while p_1 != p_2:
            if p_1 is None:
                p_1 = headB
            else:
                p_1 = p_1.next
            if p_2 is None:
                p_2 = headA
            else:
                p_2 = p_2.next
        return p_1
```


[Leetcode 19. Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)

找到一个链表的倒数第k个node，设这个list长为n，那么先让fast指针走k步，再让slow和fast一块走完剩下的（n-k），即fast走到null，那么这时候slow所指的位置就是倒数第k个。因为找到倒数第k个需要找到正数第n-k+1个，即需要走n-k步。从正数第k个走到末尾null上正好是n-k步。
删除第k个，就要找到倒数第k+1个。但是当k=length的时候这个倒数k+1是不存在的null，所以需要加一个dummy head来避免null pointer。注意在一个list的头部加dummy是不影响找倒数的，因为倒数的位置并没有发生改变，所以针对一个没有dummy head的list的findNFromEnd是可以被有dummy head 的list使用并且得到正确结果的。所以代码如下：
```python
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        dummy = ListNode()
        dummy.next = head
        prev = self.findNFromEnd(dummy, n+1)
        prev.next = prev.next.next
        return dummy.next
    def findNFromEnd(self, head, n):
        fast = head
        for _ in range(n):
            fast = fast.next
        slow = head
        while fast is not None:
            fast = fast.next
            slow = slow.next
        return slow
```
如果不想搞这么复杂，就可以稍微改一下findNFromEnd的过程。找倒数第n+1个，则可以找倒数第n个但是让slow指针少走一步，少走一步可以通过改变fast到头的判断方式,即fast==null 改为fast.next==null。
```python
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        fast, slow = head, head
        for _ in range(n): fast = fast.next
        if not fast: return head.next
        while fast.next: fast, slow = fast.next, slow.next
        slow.next = slow.next.next
        return head
```