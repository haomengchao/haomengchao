title: 刷题记录-4
author: Mengchao Hao
tags:
  - 学习
  - leetcode
categories:
  - 学习
date: 2021-11-01 14:56:00
---
#### two pointer

##### 11.1

[Leetcode 76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)

滑动窗口。基本框架为：一个dict记录target string，字母和个数；一个dict记录current window，也是字母和个数。 一个flag valid记录当前有多少字母复合要求，注意valid增加和减小的条件有且仅有字母个数在 current window和target里**相等**的时候。外循环根据right index判断，内循环根据valid和target的长度是否相等判断。

```python
from collections import defaultdict
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        sliding_window = defaultdict(int)
        target_window = defaultdict(int)
        for ch in t:
            target_window[ch] += 1
            sliding_window[ch] += 0
        left = 0 
        right = 0
        valid = 0
        result = ""
        min_length = len(s)+1
        
        while right  < len(s):
            ch = s[right]
            if ch in target_window:
                sliding_window[ch] += 1
                if sliding_window[ch] == target_window[ch]:
                    valid += 1
            right += 1
            
            while valid == len(target_window):
                current_length = right - left
                if current_length < min_length:
                    result = s[left:right]
                    min_length = current_length
                ch = s[left]
                if ch in target_window:
                #必须先判断是否相等，相等的话对valid进行更改
                    if sliding_window[ch] == target_window[ch]:
                    	valid -= 1
                    sliding_window[ch] -= 1
                left += 1
        return result
```

[Leetcode 567. Permutation in String](https://leetcode.com/problems/permutation-in-string/)

注意排列的定义，是不包括其他字符的，仅由子序列的字符组成。所以left指针到right指针的长度需要维持在size(s1)这样子的情况下，valid才有效。

```python
from collections import defaultdict
class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        target = defaultdict(int)
        window = defaultdict(int)
        for char in s1:
            target[char] += 1
        valid = 0
        left = 0 
        right = 0
        if len(s1) > len(s2):
            return False
        while right < len(s2):
            ch = s2[right]
            if ch in target:
                window[ch] += 1
                if window[ch] == target[ch]:
                    valid += 1
            right += 1
            while right - left >= len(s1):
                if right- left == len(s1) and valid == len(target):
                    return True
                ch = s2[left]
                if ch in target:
                    if window[ch] == target[ch]:
                        valid -= 1
                    window[ch] -= 1
                left += 1
        return False
```


[Leetcode 3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)

这个题的判断条件很简单，只要window dict里有count大于1的情况，left pointer就要移动。同时在大循环里维持max_length的更新，这样当window dict里一直没有重复元素的时候，max_length也能保证正确的更新，如对于情况abcb这种，结果就并没有在进入小循环里得到。其实就是在收缩窗口完成后进行判断，如果窗口不用收缩就直接判断。

```python
from collections import defaultdict
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        window = defaultdict(int)
        left = 0 
        right = 0
        max_length = 0
        while right < len(s):
            ch = s[right]
            window[ch] += 1
            right += 1
            while window[ch] > 1:
                c = s[left]
                window[c] -= 1
                left += 1
            max_length = max(max_length, right - left)
        return max_length
```