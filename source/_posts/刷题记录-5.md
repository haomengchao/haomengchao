title: 刷题记录-5
author: Mengchao Hao
tags: []
categories: []
date: 2021-11-02 15:50:00
---
#### DP
##### 11.2
买卖股票问题。本质是个动归。如果交易限制为k的话，转移方程为
```python
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
```
其中i是天数，k是目前可以交易的次数，0代表当前未持有股票，1代表当前持有股票。对于第1天，即初始天，如果今天未持有股票那么盈利应该是0，如果持有股票只能是买了股票，盈利为-prices[0]。 对于k为0的情况，就代表着无法买卖股票，我们把k=0的时候买股票的收益设为负无穷，这样在计算k=1的时候，因为是求max，买股票所扣的钱会被正确记录。并且在循环的时候k是不能小于1的。交易次数的减少发生在买股票的那天，这样可以限制无限买入。
[Leetcode 188. Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)

```python
class Solution:
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        max_k = k
        if len(prices) == 0:
            return 0
        if k > len(prices)//2:
            return self.maxProfitInfK(prices)
        dp = [[[1-sys.maxsize for i in range(2)]for j in range(max_k+1)] for _ in range(len(prices)+1)]
        for k in range(max_k + 1):
            dp[0][k][0] = 0
            dp[0][k][1] = -prices[0]
        for i in range(len(prices)+1):
            dp[i][0][0] = 0
        for i in range(len(prices)):
            for k in range(max_k,0,-1):
                dp[i+1][k][0] = max(dp[i][k][0], dp[i][k][1] + prices[i])
                dp[i+1][k][1] = max(dp[i][k][1], dp[i][k-1][0] - prices[i])
        return dp[-1][max_k][0]
                
    def maxProfitInfK(self, prices):
        dp_i_0 = 0
        dp_i_1 = -sys.maxsize
        for i in range(len(prices)):
            temp = dp_i_0
            dp_i_0 = max(temp, dp_i_1 + prices[i])
            dp_i_1 = max(dp_i_1, temp - prices[i])
        return dp_i_0
                
```
这里的优化是当k>n/2的时候，就代表着可以无限交易，问题简化成了k=inf的情况。

对于问题变种，如果要收手续费，那么相当于买股票的时候多交点钱，把扣手续费的步骤放在买股票时。如果有Cool down time，那么买卖股票的参考dp就要发生改变。比如卖了之后要等一天才能买，则dp[i+1][k][1] = max(dp[i][k][1], dp[i-1][k-1][0] - prices[i])

##### 12.6
贪心区间问题
[Leetcode 1024. Video Stitching](https://leetcode.com/problems/video-stitching/)

[Leetcode 45. Jump Game II](https://leetcode.com/problems/jump-game-ii/)

[Leetcode 1326. Minimum Number of Taps to Open to Water a Garden](https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/)

这些问题的基本都是解决使用最小个数的区间来覆盖全部区间的问题。使用Greedy来解。其实是将每段区间按start排序后，从0开始，每次我们维护当前区间的终点，起点在当前区间里的区间的最远终点。因为我们只求区间个数，所以对于每次循环，我们是基于从0到end的区间已经被完全覆盖的前提来做的，所以只要起点在这个区间里，就能保证新加的区间和我们已有的区间重合可合并，并且因为我们选的是能到达最远的那一个区间，所以count只会加1。当当前end到达终点的时候程序结束，所以循环条件是  while end < real_end，等于的时候已经需要结束了。

code exmaple

```python
class Solution:
    def minTaps(self, n: int, ranges: List[int]) -> int:
        array = [0 for i in range(n+1)]
        for i in range(n+1):
            left = max(0, i - ranges[i])
            array[left] = max(array[left], i + ranges[i])
        i = 0
        end = 0
        farcanreach = 0
        count = 0
        while i < len(array) and end < n:
            #每次只选择一个新的interval，在farcanreach之前的数字已经被覆盖完全了
            #所以新选的interval是为了尽可能覆盖以后的
            #i不能超过farcanreach是为了新的interval和之前的那些必须有交集，这才不会漏
            #end就是当前已覆盖的那个大interval的end，如果遍历了这个大interval中的数字也不能更新farcanreach
            #那就说明这个区间不能在增长了，即新的interval和当前这个中间有空隙，肯定不符合题目要求了
            count += 1
            #针对落在当前interval里的tap，选出那个能增加喷洒距离最多的interval
            while i < len(array) and i <= end:
                farcanreach = max(farcanreach, array[i])
                i += 1
            if end == farcanreach:
                return -1
            end = farcanreach
        return count
```

##### 12.7

字符串匹配问题

[Leetcode 10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/)

正则表达式匹配，注意题目中只有一个字符串可能带有正则表达式符号而不是两个都可能，所以只需要对P进行讨论。dp找状态转移方程，主要情况就是以下几点：
1. s[i]与p[j]相等或者p[j] == '.',这种情况直接匹配，所以dp[i][j] = dp[i-1][j-1]
2. s[i]与p[j]不相等但是p[j] == '`*`', 这种情况下分类讨论，主要是对 '`*`'的功能的讨论：可以匹配多个相同字符，这种情况dp[i][j] = dp[i-1][j],可以删除前面的字符，这种情况dp[i][j] = dp[i][j-2]，匹配单一字符,这种情况dp[i][j] = dp[i-1][j-2] (aaaa|a,aaaa|.*)。但对于p[j-2]不等于s[i-1]或者"."的情况，dp[i][j]只能等于dp[i][j-2]，即星号只能起到删除作用

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        m = len(s)
        n = len(p)
        dp = [[False for i in range(n+1)] for j in range(m+1)]
        dp[0][0] = True
        #特殊情况处理，对于p = (.*)*的形式，可以让星号全部发挥删除作用，与长度为零的s匹配
        for j in range(2, n + 1, 2):
            if p[j-1] == "*" and dp[0][j-2]:
                dp[0][j] = True
        for i in range(1,m+1):
            for j in range(1,n+1):
                if s[i-1] == p[j-1] or p[j-1] == ".":
                    dp[i][j] = dp[i-1][j-1]
                elif p[j-1] == "*":
                    #前面的字符相等，星号可以起到重复，单一和删除的作用
                    #dp[i-1][j] 相当于星号重复了之前的字母，所以i-1
                    #dp[i][j-1] 或者dp[i-1][j-2]相当于匹配了一次字母
                    #dp[i][j-2]相当于删除了p前面的一个字母
                    if s[i-1] == p[j-2] or p[j-2] == ".":
                        dp[i][j] = dp[i-1][j] or dp[i][j-1] or dp[i][j-2]
                    #只能删除的情况
                    else:
                        dp[i][j] = dp[i][j-2]

        return dp[m][n]
```
类似的，针对edit distance，也是三种情况： 针对字符串p,q, dp[i][j] = dp[i][j-1]: 在p里插入一个q的第j个字符或者在q里删除第j个字符；dp[i][j] = dp[i-1][j]:在p里删除第i个字符或者在q里插入一个新字符； dp[i][j] = dp[i-1][j-1] 直接把i，j字符换成相等的。

[Leetcode 72. Edit Distance](https://leetcode.com/problems/edit-distance/)

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        dp = [[0 for i in range(len(word2)+1)]for j in range(len(word1)+1)]
        for i in range(len(word1)+1):
            dp[i][0] = i
        for j in range(len(word2)+1):
            dp[0][j] = j
        for i in range(1,len(word1)+1):
            for j in range(1,len(word2)+1):
                if word1[i-1] == word2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1] ) + 1
        return dp[-1][-1]
```