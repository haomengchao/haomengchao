title: 刷题记录-5
author: Mengchao Hao
tags: []
categories: []
date: 2021-11-02 15:50:00
---
#### DP
##### 11.2
买卖股票问题。本质是个动归。如果交易限制为k的话，转移方程为
```python
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
```
其中i是天数，k是目前可以交易的次数，0代表当前未持有股票，1代表当前持有股票。对于第1天，即初始天，如果今天未持有股票那么盈利应该是0，如果持有股票只能是买了股票，盈利为-prices[0]。 对于k为0的情况，就代表着无法买卖股票，我们把k=0的时候买股票的收益设为负无穷，这样在计算k=1的时候，因为是求max，买股票所扣的钱会被正确记录。并且在循环的时候k是不能小于1的。交易次数的减少发生在买股票的那天，这样可以限制无限买入。
[Leetcode 188. Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)

```python
class Solution:
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        max_k = k
        if len(prices) == 0:
            return 0
        if k > len(prices)//2:
            return self.maxProfitInfK(prices)
        dp = [[[1-sys.maxsize for i in range(2)]for j in range(max_k+1)] for _ in range(len(prices)+1)]
        for k in range(max_k + 1):
            dp[0][k][0] = 0
            dp[0][k][1] = -prices[0]
        for i in range(len(prices)+1):
            dp[i][0][0] = 0
        for i in range(len(prices)):
            for k in range(max_k,0,-1):
                dp[i+1][k][0] = max(dp[i][k][0], dp[i][k][1] + prices[i])
                dp[i+1][k][1] = max(dp[i][k][1], dp[i][k-1][0] - prices[i])
        return dp[-1][max_k][0]
                
    def maxProfitInfK(self, prices):
        dp_i_0 = 0
        dp_i_1 = -sys.maxsize
        for i in range(len(prices)):
            temp = dp_i_0
            dp_i_0 = max(temp, dp_i_1 + prices[i])
            dp_i_1 = max(dp_i_1, temp - prices[i])
        return dp_i_0
                
```
这里的优化是当k>n/2的时候，就代表着可以无限交易，问题简化成了k=inf的情况。

对于问题变种，如果要收手续费，那么相当于买股票的时候多交点钱，把扣手续费的步骤放在买股票时。如果有Cool down time，那么买卖股票的参考dp就要发生改变。比如卖了之后要等一天才能买，则dp[i+1][k][1] = max(dp[i][k][1], dp[i-1][k-1][0] - prices[i])