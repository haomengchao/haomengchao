title: 刷题记录-6
author: Mengchao Hao
tags:
  - 学习
  - leetcode
categories:
  - 学习
date: 2021-11-03 15:59:00
---
#### 二叉树

##### 11.3

[Leetcode 105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

Construct binary tree from inorder traversal and pre order traversal. 重要的点在于找到在build left node 和right node时候的两个数组的index。对于inorder 数组好说，就是root index前面的和后面的东西。但是找preorder的index就需要借助inorder的信息了。inorder的root index 与start index之差，正好是preorder的 left part的size，所以可以借助这一点来定位preorder的index应该怎么变化。注意一定是root_index - inorder_start_index, 而不是root_index - 0

```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        return self.dfs(preorder, inorder, 0, len(preorder), 0, len(inorder))
    def dfs(self, preorder, inorder, preorder_start, preorder_end, inorder_start, inorder_end):
        if preorder_start >= preorder_end or inorder_start >= inorder_end:
            return None
        root = preorder[preorder_start]
        mid_index = inorder.index(root)
        root_node = TreeNode(root)
        left_size = mid_index - inorder_start
        left_node = self.dfs(preorder, inorder,preorder_start+1, preorder_start + left_size +1, inorder_start, mid_index)
        right_node = self.dfs(preorder, inorder, preorder_start + left_size+1 , preorder_end, mid_index+1, inorder_end)
        root_node.left = left_node
        root_node.right = right_node
        return root_node
```



##### 11.4 

[Leetcode 652. Find Duplicate Subtrees](https://leetcode.com/problems/find-duplicate-subtrees/)

注意serialize的时候要分清左子树和右子树，不然[0,null,0] 和[0,0,null]会被serialize成一样的string。 同时遍历和序列化可以在一次dfs中进行。

```python
class Solution:
    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:
        trees = {}
        result = []
        self.dfs(root, trees, result)
        return result
    def dfs(self, root, trees, result):
        if root is None:
            return "#"
        left_sub_tree = self.dfs(root.left, trees, result)
        right_sub_tree = self.dfs(root.right, trees, result)
        sub_tree = left_sub_tree +"L" + str(root.val) + right_sub_tree +"R"
        if sub_tree in trees:
            if trees[sub_tree] == 1:
                result.append(root)
            trees[sub_tree] += 1
        else:
            trees[sub_tree] = 1
        return sub_tree
```


##### Morris

空间复杂度为O(1)的traversal。核心思想是利用predecessor的right指针指向current来达到从子树返回的效果。一个node的predecessor的right一定是空，不然他就不是predecessor了。

```python
def Morris(root): 
    # Set current to root of binary tree 
    curr = root 
    
    while curr: 
        # 针对左子树为空的情况，直接print然后进入到右子树
        if curr.left is None: 
            print curr.data, 
            curr = curr.right
        else: 
            # 进入左子树之前的准备工作，建立back pointer 
            # 找到predecessor
            prev = curr.left
            # 这个prev.right ！= curr非常重要，因为我们遍历完左子树回到原结点后还会再找一次predecessor，但这时候已经有环了，必须加这个限定条件 
            while(prev.right is not None and prev.right != curr): 
                prev = prev.right

            # 如果predecessor的right没有指向，那么建立指向并且进入左子树
            if(prev.right_node is None): 
                prev.right_node = curr 
                curr = curr.left_node 
                
            # 这是从左子树回来后的情况，取消pointer，进入右子树遍历
            else: 
                prev.right_node = None
                print curr.data, 
                curr = curr.right_node 
```

##### 11.5

[Leetcode 1373. Maximum Sum BST in Binary Tree](https://leetcode.com/problems/maximum-sum-bst-in-binary-tree/)

缝合怪题。既要判断这个BST是不是有效的，又要随时更新最大的sum值。因为判断BST是不是有效和计算最大值都是后序遍历可做的，所以这个题把后序遍历的两个内容放在一块操作。所以从sub task return的东西要足够进行
1. 判断树是不是有效BST
2. 更新最大值
判断树是不是有效通过范围来做，如果左子树的最大值比root.val大或者右子树的最小值比root.val小，那就不是valid。所以return的值必定有这个子树的最小值和最大值。同时还有这个子树是不是valid的flag。要更新max_sum，就需要比较new_sum和max_sum的值，new_sum = root.val + left_sum + right_sum, 所以返回值还要有这个子树的sum

```python
class Solution:
    def __init__(self):
        self.max_sum = 0
    def maxSumBST(self, root: Optional[TreeNode]) -> int:
        res = self.dfs(root)
        return self.max_sum
       
    def dfs(self, root):
        if root is None:
            return [1,float("inf"), float("-inf"), 0]
        left = self.dfs(root.left)
        right = self.dfs(root.right)
        res = [0 for _ in range(4)]
        #0 是不是valid
        #1 子树最小值
        #2 子树最大值
        #3 子树key sum
        if left[0] == 1 and right[0] == 1 and root.val > left[2] and root.val <right[1]:
            res[0] = 1
            res[1] = min(left[1], root.val)
            res[2] = max(right[2], root.val)
            res[3] = left[3] + right[3] + root.val
            self.max_sum = max(self.max_sum, root.val + left[3] + right[3])
            return res
        else:
            return [0]
        
```

##### 11.8

[Leetcode 297 Serialize and Deserialize Binary Tree](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/)

树的序列化，用纯recursively的方法来做，其实就是树的遍历。serialize的时候要注意什么时候加分隔符，只有在真正append value的时候加一次就够了，root.left和right会自动被handle。deserialize的时候利用前序遍历/后序遍历/中序遍历的特点：前序遍历的node排序为 root，root.left, root.right。 所以对于每一次recursion来说，当前这个队列的头部就是他这个点的root，我们把它拿出来，然后队列的头就变成了 root.left的root，所以对于每次recursion我们只需要popleft，然后创建root，然后再继续recursion就行了。

1. 前序遍历法:
```python
from collections import deque
class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        result = ""
        spliter = ","
        if root == None:
            return "#" + spliter
        #只需要在真正加值的时候加spliter
        result += str(root.val) + spliter
        result += self.serialize(root.left) 
        result += self.serialize(root.right) 
        return result

    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        spliter = ","
        nodes = data.split(spliter)
        #去掉最后一个""的影响
        nodes = deque(nodes[:-1])
        return self.dfs(nodes)
        
    def dfs(self, nodes):
        if nodes is None or len(nodes) == 0:
            return None
        current = nodes.popleft()
        if current == "#":
            return None
        root = TreeNode(int(current))
        root.left = self.dfs(nodes)
        root.right = self.dfs(nodes)
        return root
```

2. 后序遍历法

后序遍历不是真的要先算left 再算right，最后算root，那根本算不出（没有出口）。后序遍历本质是通过后序序列的特点来生成树，特点就是排列方式是root.left,root.right,root。所以popleft换成popright，然后遍历的时候先右后左就行了

```python
from collections import deque
class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        result = ""
        spliter = ","
        if root == None:
            #下面没handle这种情况下加spliter，单独处理一下
            return "#" + spliter
        result += self.serialize(root.left) 
        result += self.serialize(root.right) 
        #真正添加value的地方后面加一次spliter就够了
        result += str(root.val) + spliter

        return result

    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        spliter = ","
        nodes = data.split(spliter)
        #把最后那个null去掉， 不然遍历会提前终止
        nodes = deque(nodes[:-1])
        return self.dfs(nodes)
        
    def dfs(self, nodes):
        if nodes is None or len(nodes) == 0:
            return None
        current = nodes.pop()
        if current == "#" or current == "":
            return None
        root = TreeNode(int(current))
        right = self.dfs(nodes)
        left = self.dfs(nodes)
        root.left = left
        root.right = right

        return root
```

3. 层序遍历

层序遍历在deserialize的时候要通过一个index指到当前的node，然后用一个queue存他们的parent。queue里第一个node肯定是root，bfs开始的第一个node肯定是Nodes[1],所以在遍历每个node的时候，如果这个node是一个非空node，那他一定在将来会作为bfs的parent node，所以当发现node是有值的时候，就把它加到queue里去

```python
from collections import deque
class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        result = ""
        spliter = ","
        q = deque([root])
        while q:
            current = q.popleft()
            if current is None:
                result += "#" + spliter
                continue
            result += str(current.val) + spliter
            q.append(current.left)
            q.append(current.right)
        return result
    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        spliter = ","
        nodes = data.split(spliter)
        nodes = deque(nodes[:-1])
        root = nodes[0]
        if root is "#":
            return None
        root = TreeNode(root)
        q = deque([root])
        i = 1
        while i < len(nodes):
            current = q.popleft()
            if nodes[i] != "#":
                left = TreeNode(int(nodes[i]))
                current.left = left
                q.append(left)
            i += 1
            if nodes[i] != "#":
                right = TreeNode(int(nodes[i]))
                current.right = right
                q.append(right)
            i += 1
        return root
```


##### 11.10

[Leetcode 863. All Nodes Distance K in Binary Tree](https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/)

找距离某点k的所有node，这道题如果是个图题会非常好做，可惜是个树题，但是树就是图，我们可以将树转化为图。使用一个parent map将每个node 的parent记录下来，就相当于有了所有node 的neighbors。然后再BFS遍历即可。

```python
import collections
class Solution:
    def distanceK(self, root: TreeNode, target: TreeNode, k: int) -> List[int]:
        def buildGraph(node, parent,graph):
            if node is None:
                return 
            #针对root node的情况处理
            if parent is not None:
                graph[node].append(parent)
            if node.left is not None:
                graph[node].append(node.left)
                buildGraph(node.left, node, graph)
            if node.right is not None:
                graph[node].append(node.right)
                buildGraph(node.right, node, graph)
        graph = defaultdict(list)
        buildGraph(root, None, graph)
        q = deque([(target, 0)])
        visited = set()
        visited.add(target)
        result = []
        while q:
            current_node, current_distance = q.popleft()
            if current_distance == k:
                result.append(current_node.val)
            for neighbor in graph[current_node]:
                if neighbor not in visited:
                    q.append((neighbor, current_distance + 1))
                    visited.add(neighbor)
        return result
```

[Leetcode 314. Binary Tree Vertical Order Traversal](https://leetcode.com/problems/binary-tree-vertical-order-traversal/)

用BFS比DFS直观一点，因为BFS常规来说是从上往下，从左往右的顺序来遍历，而题目的要求也是这个顺序。这样每个column map里的顺序就是最终顺序不需要再处理。如果要求重合点的顺序是按值排序的话，则需要额外记录点的row，根据key1=row，key2=value来排序。

```python
from collections import defaultdict, deque
class Solution:
    def verticalOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if root is None:
            return []
        column_map = defaultdict(list)
        q = deque([(root, 0)])
        while q:
            current_node, col = q.popleft()
            column_map[col].append(current_node.val)
            if current_node.left:
                q.append((current_node.left, col - 1))
            if current_node.right:
                q.append((current_node.right, col + 1))
        result = []
        for key in sorted(list(column_map.keys())):
            result.append(column_map[key])
        return result
            
```

##### 11.11

###### N-ary tree tranversal

[Leetcode 589. N-ary Tree Preorder Traversal](https://leetcode.com/problems/n-ary-tree-preorder-traversal/)

iteratively 和 recurssively。Iteratively就反向stack就可以了，反向装node，每拿出一个把他的children反向push进去

```python
class Solution:
    def preorder(self, root: 'Node') -> List[int]:
        if root is None:
            return None
        stack = []
        stack.append(root)
        result = [] 
        while stack:
            current = stack.pop()
            result.append(current.val)
            for i in range(len(current.children) -1, -1, -1):
                stack.append(current.children[i])
        return result
class Solution:
    def preorder(self, root: 'Node') -> List[int]:
        def dfs(root,result):
            if root is None:
                return 
            result.append(root.val)
            for child in root.children:
                dfs(child, result)
        result = []
        dfs(root, result)
        return result
```
不用额外空间，增加parent指针怎么做： 用index指示当前node下一个child是哪个。用一个dummynode，保证root也可以被输出。preorder就是先处理路上的，再处理leaf的，所以在go down的过程中来输出。这样输出完一个leaf后，go to parent然后在下一个循环又进入了新的leaf，是正确的输出顺序。如果所有leaf都处理完了就go dummy node，然后更新dummy的index，dummy就不会再继续往下走，而是走到dummy的parent None，从而结束循环。

```python
dummy = node(-1)
dummy.children.append(root)
head = dummy
while head:
	#go down
	while head.index < len(head.children):
		head = head.children[head.index]
		print(head.val)
	#cannot go further down, which means all the children are processed 
	# go up
	head = head.parent
	if head is not None:
		head.index += 1
```
[Leetcode 590. N-ary Tree Postorder Traversal](https://leetcode.com/problems/n-ary-tree-postorder-traversal/)

iterative,翻转最后的result即可，相当于结果是push到一个stack里的，正确的顺序要把stack反过来。

```python 
class Solution:
    def postorder(self, root: 'Node') -> List[int]:
        if root is None:
            return None
        stack = [root]
        result = []
        while stack:
            current = stack.pop()
            result.append(current.val)
            for child in current.children:
                stack.append(child)
        return result[::-1]
        
class Solution:
    def postorder(self, root: 'Node') -> List[int]:
        def dfs(root, result):
            if root is None:
                return 
            for child in root.children:
                dfs(child, result)
            result.append(root.val)
        result = []
        dfs(root,result)
        return result
```

不用额外空间 增加parent指针。做法和上题类似，只是输出结果的位置改变，不能在寻找node的过程中输出，而是在找到node后再输出。这样的话只会在返回parent node 的时候输出上级node的val，相当于post order

```python
root = node_1
dummy = node(-1)
dummy.children.append(root)

head = dummy
while head:
	#go down
	while head.index < len(head.children):
		head = head.children[head.index]
	#cannot go further down, which means all the children are processed 
	print(head.val)
	# go up
	head = head.parent
	if head is not None:
		head.index += 1
```


##### 11.17
[Leetcode 2003. Smallest Missing Genetic Value in Each Subtree](https://leetcode.com/problems/smallest-missing-genetic-value-in-each-subtree/)

题目属于tree，但是并不是一个真正的tree的形式，而是一系列数组代表这个tree。本质是找Subtree first missing number. naive的想法是找到每个subtree（构成值数组）然后对每个数组找first missing，但是肯定超时。
优化做法是：只考虑包含值为1的路径上的subtree。因为不包含1的路径上的subtree的first missing肯定是1，不需要进一步研究，但是如果一个subtree里包含1了，那么就得从值为1的结点出发，向上一直找，同时更新first missing。
具体做法是维护一个seen数组，记录当前已经visited的数值，这样在找first missing的时候只要每次再往后遍历一下seen就可以了。从值为1的node出发，向它的parent走，每遇到一个节点就是一个subtree，要visited all nodes of this tree然后更新seen数组。

```python
from collections import defaultdict
class Solution:
    def smallestMissingValueSubtree(self, parents: List[int], nums: List[int]) -> List[int]:
        children = defaultdict(list)
        #为遍历subtree作准备
        for i in range(len(nums)):
            children[parents[i]].append(i)
        seen = [0 for i in range(100010)]
        result = [1 for i in range(len(nums))]
        #如果1根本没在nums中出现那么所有的结果都是1
        if 1 not in nums:
            return result
        def dfs(i):
            if seen[nums[i]] == 0:
                for j in children[i]:
                    dfs(j)
                seen[nums[i]] = 1
        i = nums.index(1)
        first_missing = 1
        while i != -1:
            dfs(i)
            while seen[first_missing]:
                first_missing += 1
            result[i] = first_missing
            i = parents[i]
        return result
            
```

##### 11.18

[Leetcode 894. All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/)

经典的利用dfs的题。dfs子问题可以返回正确的结果，把返回的正确的结果通过正确的方式构建树，那么子问题的正确结果就可以被保证，原本问题也就被解决了

```python
class Solution:
    def allPossibleFBT(self, n: int) -> List[Optional[TreeNode]]:
        memo = {}
        root = TreeNode()
        if n % 2 == 0:
            return []
        if n ==1:
            return [root]
        result = []
        #左子树个数，奇数
        for i in range(1, n-1, 2):
        #所有可能的左边树，就是construct from left
            for left in self.allPossibleFBT(i):
            #同理 所有可能的右边树
                for right in self.allPossibleFBT(n-1-i):
                #直接把树构建起来
                    new_root = TreeNode()
                    new_root.left = left
                    new_root.right = right
                    result.append(new_root)
        memo[n] = result
        return memo[n]
       
```

[Leetcode 428. Serialize and Deserialize N-ary Tree](https://leetcode.com/problems/serialize-and-deserialize-n-ary-tree/)

N-ary tree deserialzie and serialize.和binary tree最大的区别在于children node的个数是不清楚的。对于binary我们知道肯定一个left 一个right，至于left和right有没有没关系，我们可以用一个特殊符号来代替，这样对于每个node都是两次操作，一次从queue里poll出来left，一次从queue里poll出来right，而对于n-ary来说这个操作次数是未知的。但如果在serialize的时候告诉node有几个children，那么操作数就确定了，这个问题就可以用解决binary tree的方式来解决

```python
from collections import deque
class Codec:
    def serialize(self, root: 'Node') -> str:
        """Encodes a tree to a single string.
        
        :type root: Node
        :rtype: str
        """
        result = []
        self.serializeHelper(root, result)
        return ",".join(result)
    def serializeHelper(self, root, result):
        if root is None:
            return ''
        #对于每个node，先加value，再加children个数，然后依次去serialize children
        result.append(str(root.val))
        result.append(str(len(root.children)))
        for child in root.children:
            self.serializeHelper(child, result)
	
    def deserialize(self, data: str) -> 'Node':
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: Node
        """
        if data == "":
            return None
        queue = deque(data.split(','))
        return self.deserializeHelper(queue)
        
    def deserializeHelper(self, queue):
    	  #第一个是root的value， 第二个是chilren的个数
        root = Node(int(queue.popleft()))
        children = int(queue.popleft())
        root.children = []
        #有了children 个数就知道应该把哪些node放进来了
        for i in range(children):
            root.children.append(self.deserializeHelper(queue))
        return root
```
##### 11.21

[Leetcode 834. Sum of Distances in Tree](https://leetcode.com/problems/sum-of-distances-in-tree/)

问题转化：如果已知所有node到点A的距离，那么所有node到点B的距离为：distance_sum_to_A + ((N - count[B]) - (count[B])) * distance_A_to_B. 其中count是这个子树的node的个数，包括root。如果B是A的child，那么这个distance_A_to_B就是1。所以可以先走一遍获取每个子树node的个数，同时是从root出发的dfs也可以算出来所有node到root的距离（sum_distance[root] = sum(sum_distance[child]） + sum(count[child])。然后再走一遍dfs，从root开始更新每个node的distance_sum

```python
from collections import defaultdict, deque
class Solution:
    def sumOfDistancesInTree(self, n: int, edges: List[List[int]]) -> List[int]:
        graph = defaultdict(list)
        for edge in edges:
            start = edge[0]
            to = edge[1]
            graph[start].append(to)
            graph[to].append(start)
        count = [1] * n
        sums = [0] * n
        def dfs(node, parent):
            for neighbor in graph[node]:
                if neighbor != parent:
                    dfs(neighbor, node)
                    count[node] += count[neighbor]
                    sums[node] += sums[neighbor] + count[neighbor]
                    
                    
        def dfs2(node,parent):
            for neighbor in graph[node]:
                if neighbor != parent:
                    sums[neighbor] = sums[node] - count[neighbor] + n - count[neighbor]
                    dfs2(neighbor, node)
        dfs(0, None)
        dfs2(0, None)
        return sums
```

[Leetcode 437. Path Sum III](https://leetcode.com/problems/path-sum-iii/)

prefix_sum和two sum 和 binary tree的缝合。找路径上任意两点之间的路径和为target，就可以用prefix_sum+two_sum的方法来做。具体是：当遇到一个新的数值的时候，path_sum(prefix_sum) += val,然后首先判断当前路径和是不是target，如果是的话就有一次count。然后根据two sum的思想，target = current_sum - old_sum -> old_sum = current_sum - target。 我们就可以通过判断这个old_sum在不在路径中存在就行。如果存在的话，count要加上old_sum的次数。由于prefix sum是从root到leaf累加的，所以这样的顺序保证了我们可以通过O(n)的时间复杂度边计算prefix sum边推导count.

就是[Leetcode 560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)的变种

```python
from collections import defaultdict
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:
        count = 0
        prefix_sum = defaultdict(int)
        def dfs(root, targetSum, path_sum):
            nonlocal count
            if root is None:
                return 
            current_sum = path_sum + root.val
            if current_sum == targetSum:
                count += 1
            count += prefix_sum[current_sum - targetSum]
            
            prefix_sum[current_sum] += 1
            dfs(root.left, targetSum, current_sum)
            dfs(root.right, targetSum, current_sum)
            prefix_sum[current_sum] -= 1
        dfs(root, targetSum, 0)
        return count
```

##### 11.23
###### segment tree

[Leetcode 307. Range Sum Query - Mutable](https://leetcode.com/problems/range-sum-query-mutable/)

经典的segment tree的应用，求range_sum, 也可以求range_min, range_max。 构建tree的时间复杂度是O(n), update 和query 都是O(logn)。
segment tree就是二叉树多加一些property，其中多加的有start，end和sum（如果求range sum的话）。[start,end]代表这个node是原数组哪些范围的数的和。

```python
class Node:
    def __init__(self, start, end):
        self.start = start
        self.end = end
        self.sum = 0
        self.left = None
        self.right = None
class NumArray:

    def __init__(self, nums: List[int]):
        def build_tree(start, end):
            if start >end:
                return None
            #到leaf结点，直接赋值
            if start == end:
                node = Node(start, end)
                node.sum = nums[start]
                return node
            mid = start +(end - start) // 2
            root = Node(start, end)
            root.left = build_tree(start, mid)
            root.right =  build_tree(mid+1,end)
            #一定要有对root的sum的更新
            root.sum = left_node.sum + right_node.sum
            return root
        self.root = build_tree(0,len(nums) - 1)

    def update(self, index: int, val: int) -> None:
        def update_tree(index, val, node):
            #找到了leaf结点，直接更新
            if node.start == node.end:
                node.sum = val
                return 
            mid = node.start + (node.end - node.start) // 2
            #根据数在数组中的index和mid作比较来决定去左子树还是右子树
            if index <= mid:
                update_tree(index, val, node.left)
            else:
                update_tree(index, val, node.right)
            #最后一定要更新当前node的sum
            node.sum = node.left.sum +node.right.sum
        update_tree(index, val, self.root)
                
    def sumRange(self, left: int, right: int) -> int:
        def query(left, right, node):
            if left >right:
                return 0
            if node is None:
                return 0
            #只有这个node的start 和end与query区间完全重合的时候才能直接返回
            if node.start == left and node.end == right:
                return node.sum
            mid = node.start +(node.end - node.start) // 2
            #query 范围完全在右子树
            if right <= mid:
                return query(left, right, node.left)
            #完全在左子树
            elif left >= mid +1:
                return query(left, right, node.right)
            #范围跨越了左和右，那么query边界就要发生相应的更新，以mid分隔开
            return query(left, mid, node.left) + query(mid+1, right, node.right)
        return query(left, right, self.root)
```
还有一种只用数组的写法：
```python
class NumArray:

    def __init__(self, nums: List[int]):
        self.nums = nums
        self.size = len(nums)
        #用一个数组来表示segment_tree,类似heap，其中左子树index是2*index，右子树是2*index+1
        self.segment_tree = [0 for i in range(4*self.size)]
        self.build_segment_tree()
    def build_segment_tree(self):
        #root的index 是1
        self.build(1, 0, self.size-1)
    def build(self, index, left, right):
        if left == right:
            self.segment_tree[index] = self.nums[left]
            return 
        mid = left + (right - left) // 2
        #build 左右子树，通过更新index和范围
        self.build(2 * index, left, mid)
        self.build(2*index + 1, mid + 1, right)
        #更新当前node
        self.segment_tree[index] = self.segment_tree[2*index] + self.segment_tree[2*index + 1]
    #这里面的left 和right就相当于是用node 方式写法的node里的start 和end
    #index 是这个node在数组中的位置
    #所以在用node的写法中是没有这三个property的
    def update_segment_tree(self, index, left, right, val, position):
        if left == right:
            self.segment_tree[index] = val
            return 
        mid = left +(right - left) // 2
        if position <= mid:
            self.update_segment_tree(2 *index, left, mid, val, position)
        else:
            self.update_segment_tree(2 * index + 1, mid +1, right, val, position)
        self.segment_tree[index] = self.segment_tree[2*index] + self.segment_tree[2*index+1]
    def range_query(self, index, current_left, current_right, left, right):
        if left > right:
            return 0
        if left == current_left and right == current_right:
            return self.segment_tree[index]
        mid = current_left +(current_right - current_left) // 2
        #省去判断的一个通用写法，要同时更新当前上下界和query上下界
        return self.range_query(index * 2, current_left, mid, left, min(right, mid)) + self.range_query(index*2+1, mid+1, current_right, max(left, mid+1), right)
    def update(self, index: int, val: int) -> None:
        position = index
        self.nums[index] = val
        self.update_segment_tree(1, 0, self.size-1,val, position)
        
    def sumRange(self, left: int, right: int) -> int:
        return self.range_query(1, 0, self.size-1, left, right)
```