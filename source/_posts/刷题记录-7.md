title: 刷题记录-7
author: Mengchao Hao
tags:
  - 学习
  - leetcode
categories:
  - 学习
date: 2021-11-09 08:32:00
---
#### 图的相关算法

##### 11.9

###### 双色问题

[Bipartition](https://en.wikipedia.org/wiki/Bipartite_graph)

解决这种问题一般是bfs或者dfs然后顺便染色，如果有两个相邻node的颜色是一样的就无法bipartition。

[Leetcode 785. Is Graph Bipartite?](https://leetcode.com/problems/is-graph-bipartite/)

双色基本BFS框架。需要colors数组记录颜色，visited数组记录node是否访问过。由于有些node根本不在关系网中，所以需要对每个node进行遍历，所有的染色没问题整个图才是没问题的双色图。这里把访问时的操作往前放，即对neighbor node的判断不在访问到neighbor的时候做，而是在访问previous node的时候做，主要是这样写比较清晰。如果neighbor 没访问到，就给他染反色然后标记访问，如果访问过就判断颜色是否合法即可。

```python
from collections import deque
class Solution:
    def isBipartite(self, graph: List[List[int]]) -> bool:
        nums = len(graph)
        colors = [False for i in range(nums)]
        visited = [False for i in range(nums)]
        for node in range(nums):
            if visited[node]:
                continue
            q = deque([node])
            visited[node] = True
            while q:
                current_node = q.popleft()
                for next_node in graph[current_node]:
                    if not visited[next_node]:
                        colors[next_node] = not colors[current_node]
                        visited[next_node] = True
                        q.append(next_node)
                    else:
                        if colors[next_node] == colors[current_node]:
                            return False
        return True
```


###### Union-Find

[Leetcode 323. Number of Connected Components in an Undirected Graph](https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/)

union find 基本框架，包括路径压缩和树的权重拼接。要注意有路径压缩的UF parent tree的高度是不会超过3的，所以find 和union都是O(1)的时间复杂度，构造UF是O(n)

```python
class Solution:
    class UnionFind:
        def __init__(self, n):
            self.parent = [i for i in range(n)]
            self.size = [1 for i in range(n)]
            self.count = n
        def find(self, node):
            while self.parent[node] != node:
                self.parent[node] = self.parent[self.parent[node]]
                node = self.parent[node]
            return node
        def union(self, p, q):
            root_p = self.find(p)
            root_q = self.find(q)
            if root_p != root_q:
                if self.size[p] > self.size[q]:
                    self.parent[root_q] = root_p
                    self.size[root_p] += self.size[root_q]
                else:
                    self.parent[root_p] = root_q
                    self.size[root_q] += self.size[root_p]
                self.count -= 1
        def counts(self):
            return self.count
    def countComponents(self, n: int, edges: List[List[int]]) -> int:
        uf = Solution.UnionFind(n)
        for edge in edges:
            uf.union(edge[0], edge[1])
        return uf.counts()
```


###### 名人问题

[Leetcode 277. Find the Celebrity](https://leetcode.com/problems/find-the-celebrity/)

传统来想，名人在图里的indegree是n-1，outdegree是0（除了自己）。但这样需要O(n^2)的遍历才能找到。
简化思想来看，如果i知道j，那么i肯定不会是名人，j更有可能是名人。所以从0到n-1找到那个可能性最高的candidate，最后再都走一遍验证所有人都知道他，他不知道所有人即可。Follow up 如果问那个knows function的复杂度太高怎么办，可以用cache把结果存住，这样空间复杂度变成O(n)但是时间上会快点。

```python
from collections import defaultdict
class Solution:
    def findCelebrity(self, n: int) -> int:
        candidate = 0
        for i in range(1,n):
            if knows(candidate,i):
                candidate = i
        for i in range(n):
            if i == candidate:
                continue
            if knows(candidate,i) or not knows(i, candidate):
                return -1
        return candidate
```

##### Dijkstra

[Leetcode 743. Network Delay Time](https://leetcode.com/problems/network-delay-time/)

[Leetcode 1514. Path with Maximum Probability](https://leetcode.com/problems/path-with-maximum-probability/)

Dijkstra模板。跟传统bfs多出来的东西一个是distance，一个是pq。distance记录从出发点到其他点的最短距离，pq里放的是node + distance_from_start。每次优先拿出最小距离的next_node然后基于其计算接下来的node的distance。
Dijkastra不会有visited来防止重复访问，因为Dijkastra需要重复访问node来更新其距离。

```python
import sys
import heapq
class Solution:
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        distance = [sys.maxsize for i in range(n+1)]
        distance[k] = 0
        priority_queue = [(0,k)]
        heapq.heapify(priority_queue)
        while priority_queue:
            current_distance, current_node = heapq.heappop(priority_queue)
            #为了效率，删掉也没问题
            if current_distance > distance[current_node]:
                continue
            next_edges = self.findNexts(times, current_node)
            for next_edge in next_edges:
                next_node = next_edge[1]
                #更新distance并和最小距离比较
                distance_to_next_node = distance[current_node] + next_edge[2]
                if distance_to_next_node < distance[next_node]:
                    distance[next_node] = distance_to_next_node
                    heapq.heappush(priority_queue, (distance_to_next_node, next_node))
        max_time = max(distance[1:])
        return -1 if max_time == sys.maxsize else max_time
    def findNexts(self, times, start):
        result = []
        for time in times:
            if time[0] == start:
                result.append(time[:])
        return result
```

```python
from collections import defaultdict
import heapq
class Solution:
    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:
        neighbors = defaultdict(list)
        probability = [0.0 for i in range(n)]
        probability[start] = 1
        for i in range(len(edges)):
            edge = edges[i]
            p = edge[0]
            q = edge[1]
            score = succProb[i]
            neighbors[p].append((q, score))
            neighbors[q].append((p, score))
        pq = [(-1,start)]
        while pq:
            current_prob, current_node = heapq.heappop(pq)
            current_prob *= -1
            if current_node == end:
                return current_prob
            if current_prob < probability[current_node]:
                continue
            for neighbor in neighbors[current_node]:
                next_node, edge_score = neighbor
                path_score = current_prob * edge_score
                if path_score > probability[next_node]:
                    probability[next_node] = path_score
                    heapq.heappush(pq, (-path_score, next_node))
        return probability[end]
```


##### 11.17

[Leetcode 332. Reconstruct Itinerary](https://leetcode.com/problems/reconstruct-itinerary/)

Eulerian Path, 遍历图中所有edge的一种算法，并且每个edge会遍历一次。这个路径叫Eulerian circuit. 判断图里是否有这个circuit的条件是至多有一个node入度比出度少1，至多有一个node出度比入度少1。算法就是一个对图的后序遍历，每到一个结点后就开始往下走，直到走到不能走（没有neighbor）的时候，把这个node放到path中，这就是path的终点。然后回退，回退到能走的下一个node，然后继续走。DFS可以很好的完成回退操作。

所以这道题的本质是找一个Eulerian path并且字母顺序是最小的，而且保证了这个path是一定有的。所以需要考虑的就是如何实现Eulerian path是字母序最小。Greedy的思想是每次选取下一个airport的时候，就选取那个有最小字母序的，如果到最后能走完这个path，那这个就是最优解。如果走不完就退而求其次。注意Eulerian是倒着走的，最后的结果是原来结果的一个倒序，如果要保证原来的path字母序最小，那么这个倒序的字母序就最大，所以针对每个node 的next node，把它按大到小排序，然后遍历。这样第一个被push到result的node必定是字母序大的,最后反一下就是最小的顺序。

```python
from collections import defaultdict
class Solution:
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        graph = defaultdict(list)
        for ticket in tickets:
            start = ticket[0]
            dest = ticket[1]
            graph[start].append(dest)
        for key in graph.keys():
            graph[key].sort(reverse = True)
        result = []
        def dfs(airport):
            nonlocal graph, result
            while graph[airport]:
                dfs(graph[airport].pop())
            result.append(airport)
        dfs("JFK")
        return result[::-1]
```


[Leetcode 787. Cheapest Flights Within K Stops](https://leetcode.com/problems/cheapest-flights-within-k-stops/)

这道题有多种解法，第一种是Dijkstra。有向图，无负权重边，找最短距离首先考虑dijkstra。这道题多一个限制条件步数，所以要在push进pq的时候和更新距离的时候多做判断。首先如果当前点的步数已经超过限制的话（k+1），那么不考虑基于这个点的下一步。在push进pq的时候，如果当前的步数比已有记录的步数更优的话，也将其作为一种可能性push进pq。
```python
import heapq
class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
        graph = [[0 for i in range(n)] for j in range(n)]
        for flight in flights:
            start = flight[0]
            to = flight[1]
            cost = flight[2]
            graph[start][to] = cost
        #起点到各点的距离
        distance_from_src= [float("inf") for i in range(n)]
        steps = [0 for i in range(n)]
        distance_from_src[src] = 0
        #首先按距离排序，再按步数排序
        pq = [(0,0,src)]
        heapq.heapify(pq)
        while pq:
            current_distance, step, current_node = heapq.heappop(pq)
            #根据dijkstra的原理，每次拿到的必定是距离最小的，所以如果到了dst直接返回就行
            if current_node == dst:
                return current_distance
            #步数超过限制的不考虑
            if step == k + 1:
                continue 
            for neighbor in range(n):
                if graph[current_node][neighbor] > 0:
                    #距离更优，更新距离
                    if current_distance + graph[current_node][neighbor] < distance_from_src[neighbor]:
                        distance_from_src[neighbor] = current_distance + graph[current_node][neighbor]
                        steps[neighbor] = step
                        heapq.heappush(pq, (current_distance + graph[current_node][neighbor], step + 1, neighbor))
                    #步数更优，作为备选考虑
                    elif step < steps[neighbor]:
                        heapq.heappush(pq,(current_distance + graph[current_node][neighbor], step + 1, neighbor))
        return -1 if distance_from_src[dst] == float("inf") else distance_from_src[dst]
```

第二种记忆dfs，因为直接dfs会TLE，同时对一个node如果访问他的时候剩下的步数一致的情况可以用memo来降低时间复杂度

```python
from collections import defaultdict
class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
        graph = defaultdict(list)
        for flight in flights:
            start = flight[0]
            to = flight[1]
            price = flight[2]
            graph[start].append((to, price))
        memo = {}
        def dfs(src, dst, k):
            if src == dst:
                return 0
            if k < 0:
                return float("inf")
            if (src,k) in memo:
                return memo[(src,k)]
            result = float("inf")
            for neighbor, next_price in graph[src]:
                result = min(result, dfs(neighbor, dst, k - 1) + next_price)
            memo[(src, k)] = result
            return result
        result = dfs(src, dst, k)
        return -1 if result == float("inf") else result
```

[Leetcode 1192. Critical Connections in a Network
](https://leetcode.com/problems/critical-connections-in-a-network/)

```python
#Tarjan algorithm
#判断一个边是否是critical的方法就是判断node有没有不走这条边的回路
#利用一个rank来记录每个node被access到的时间，这样来给node排个序，如果从一个node出发能走到时间比较前的node的话，说明有回路
#这样可以判断一个边是否是critical的，如果之后的node都不可能回到再之前的node的话，那说明没有回路，这条边就是critical edge
from collections import defaultdict
class Solution:
    def criticalConnections(self, n: int, connections: List[List[int]]) -> List[List[int]]:
        graph = defaultdict(list)
        for connection in connections:
            u = connection[0]
            v = connection[1]
            graph[u].append(v)
            graph[v].append(u)
        rank = 0
        #lowest_ranks是从一个node出发，记录他能遇到的rank最低的node，说明这个node是可以access到发现时间较早的node
        lowest_ranks = [n+1 for i in range(n)]
        #disc是这个node被发现的时间，对一个边作比较的时候，如果之后的node可以遇到比当前node发现时间更早的node，则说明有回路
        disc = [-1 for i in range(n)]
        visited = [False for i in range(n)]
        result = []
        def dfs(prev_node, current_node):
            nonlocal n, rank
            #当每个node第一次被访问的时候，他的lowest rank就是自己
            lowest_ranks[current_node] = rank
            disc[current_node] = rank
            rank += 1
            visited[current_node] = True
            for next_node in graph[current_node]:
                #不能走来时的路，因为要找其他回路
                if next_node == prev_node:
                    continue 
                if not visited[next_node]:
                    dfs(current_node, next_node)
                #更新我当前node可以遇到的最低rank的node
                lowest_ranks[current_node] = min(lowest_ranks[current_node], lowest_ranks[next_node])
                #判断：必须基于当前node的发现时间和下一个node可以接触到的最低node作对比才有意义
                #因为lowestRank不会完全被updated，不准
                #参考test case
                #6
                #[[0,1],[1,2],[2,3],[3,0],[3,4],[4,0],[4,5],[5,1]]
                if disc[current_node] < lowest_ranks[next_node]:
                    result.append([current_node, next_node])
        #对于森林的情况
        for i in range(n):
            if not visited[i]:
                dfs(-1, i)
        return result
```