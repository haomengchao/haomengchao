title: 刷题记录-8
author: Mengchao Hao
tags:
  - 学习
  - leetcode
categories:
  - 学习
date: 2021-11-11 08:33:00
---
#### 数据结构设计

##### 11.11

###### LRU

[Leetcode 146. LRU Cache](https://leetcode.com/problems/lru-cache/)

Double linked list做法。用moveToTail将node放到尾部，尾部是最近访问的数据。注意如果新加node的话直接使用这个就可以，但是如果将list中已有的node放到尾部需要先remove掉那个node，再把node放到尾部。
```python
class Node:
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None
        
class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.size = 0
        self.map = {}
        self.head = Node(-1,-1)
        self.tail = Node(-1,-1)
        self.head.next = self.tail
        self.tail.prev = self.head
    def moveToTail(self, node):
        prev = self.tail.prev
        prev.next = node
        node.prev = prev
        node.next = self.tail
        self.tail.prev = node
    def removeNode(self,node):
        node.prev.next = node.next
        node.next.prev = node.prev
        node.next = None
        node.prev = None
    def get(self, key: int) -> int:
        if key not in self.map:
            return -1
        node = self.map[key]
        self.removeNode(node)
        self.moveToTail(node)
        return node.value

    def put(self, key: int, value: int) -> None:
        if key in self.map:
            node = self.map[key]
            node.value = value
            self.removeNode(node)
            self.moveToTail(node)
        else:
            node = Node(key, value)
            self.moveToTail(node)
            self.map[key] = node
            self.size += 1
            if self.size > self.capacity:
                self.removeHead()
    def removeHead(self):
        node = self.head.next
        self.head.next = node.next
        node.next.prev = self.head
        del self.map[node.key]
        node.next = None
        node.prev = None
        self.size -= 1
        


# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)
```

###### LFU

[Leetcode 460. LFU Cache](https://leetcode.com/problems/lfu-cache/)

用两个map+linkedlist来做。一个map是key value map，一个map是freq doublelinkedlist map。Cache里要记录最小freq，方便移除最后一个node。注意删node的时候要把node从key value map中删掉，node的update 在get 和put的时候都会用到，可以单独写一个出来。

```python
class Node:
    def __init__(self,key, value):
        self.key = key
        self.value = value
        self.freq = 1
        self.prev = None
        self.next = None
class DoubleLinkedList:
    def __init__(self):
        self.head = Node(-1,-1)
        self.tail = Node(-1,-1)
        self.head.next = self.tail
        self.tail.prev = self.head
        self.size = 0
    def add(self,node):
        prev = self.tail.prev
        prev.next = node
        node.prev = prev
        node.next = self.tail
        self.tail.prev = node
        self.size += 1
    def remove(self,node):
        node.prev.next = node.next
        node.next.prev = node.prev
        node.prev = None
        node.next = None
        self.size -= 1
    def removeHead(self):
        if self.size > 0:
            node = self.head.next
            self.remove(node)
            return node
        return None
class LFUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.value_map = {}
        self.min_freq = 1
        self.freq_map = {}
        self.size = 0
        
    def update(self,node):
        freq = node.freq
        prev_list = self.freq_map[freq]
        prev_list.remove(node)
        if prev_list.size == 0 and self.min_freq == freq:
            self.min_freq += 1
        freq += 1
        node.freq = freq
        if freq not in self.freq_map:
            self.freq_map[freq] = DoubleLinkedList()
        next_list = self.freq_map[freq]
        next_list.add(node)
    def get(self, key: int) -> int:
        if key in self.value_map:
            node = self.value_map[key]
            self.update(node)
            return node.value
        else:
            return -1
            
    def removeLast(self):
        linkedList = self.freq_map[self.min_freq]
        node = linkedList.removeHead()
        del self.value_map[node.key]
        self.size -= 1
        
    def put(self, key: int, value: int) -> None:
        if self.capacity == 0:
            return -1
        if key in self.value_map:
            node = self.value_map[key]
            node.value = value
            self.update(node)
        else:
            node = Node(key, value)
            self.value_map[key] = node
            if self.size == self.capacity:
                self.removeLast()
            self.min_freq = 1
            freq = node.freq
            if freq not in self.freq_map:
                self.freq_map[freq] = DoubleLinkedList()
            current_list = self.freq_map[node.freq]
            current_list.add(node)
            self.size += 1
```

##### 11.13

[Leetcode 295. Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/)

数据流中位数，使用两个heap来解决。如果把数据分为两个有序部分，一部分值都小于另一部分，那么中位数一定是：小部分的最大的，大部分的最小的，或者两数的平均数。所以我们用一个最大堆记录小值部分的最大，用最小堆记录大值里面的最小，这样就能快速查找中位数。

注意数据进堆的方式。我们设定保证小值部分的个数不大于大值，即两个堆大小相等的时候我们往大堆里面添加数据。添加数据的同时还要维护两个堆里的数字必须是永远小于/大于另一部分的。所以在向大堆添加数据时，应该先将这个数据放入小堆，然后从小堆中pop出最大的放给大堆。这样操作保证了小堆中元素个数不变，只是元素更新，并且元素永远小于大堆（最大的值已经进入到大堆里去了）。同理当大堆元素个数大于小堆的时候，我们会pop出大堆的最小放入小堆，也保证了大堆永远大于小堆。

还要注意结果返回的时候不能用heapq.heappop。只是返回数据的值，不能移动数据

```python
import heapq
class MedianFinder:

    def __init__(self):
        self.small = []
        self.large = []

    def addNum(self, num: int) -> None:
        if len(self.small) >= len(self.large):
            heapq.heappush(self.small, -1 * num)
            heapq.heappush(self.large, -1 * heapq.heappop(self.small))
        else:
            heapq.heappush(self.large, num)
            heapq.heappush(self.small, -1  * heapq.heappop(self.large))
    def findMedian(self) -> float:
        if len(self.small) < len(self.large):
        #特别注意，不要写成return heapq.pop
            return self.large[0]
        else:
            return (-1 * self.small[0] + self.large[0]) / 2

```