title: 刷题记录-9
author: Mengchao Hao
date: 2021-11-16 09:38:52
tags:
---
#### DFS相关

##### 11.16

[Leetcode 698. Partition to K Equal Sum Subsets](https://leetcode.com/problems/partition-to-k-equal-sum-subsets/)

判断数字能否放到k个篮子里并且每个篮子的数字和相等。这题不太好找到遍历的对象，其实遍历的对象有两种，一种是针对每个数字，尝试放到每个篮子里；另一种是针对每个篮子，尝试拿取一些数字。但这两种的时间复杂度是不一样的，n个数字k个篮子，第一种复杂度是O(k^n)，第二种是O(k*2^n)(k个篮子，每个篮子进行2^n次判断，装进去或不装进去）。

```python
#针对数字遍历篮子
class Solution:
    def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:
        nums_sum = sum(nums)
        if nums_sum % k != 0:
            return False
        if k > len(nums):
            return False
        target = nums_sum // k
        buckets = [0 for i in range(k)]
        #数字从大到小排列，这样更容易剪枝
        nums.sort(reverse = True)
        return self.dfs(nums, buckets, 0, target)
    def dfs(self, nums, buckets, index, target):
        if index == len(nums):
        #出口是当所有数字都选取完了之后，判断篮子和是不是都是target
            for bucket in buckets:
                if bucket != target:
                    return False
            return True
        for i in range(len(buckets)):
            if buckets[i] + nums[index] > target:
                continue
            buckets[i] += nums[index]
            if (self.dfs(nums, buckets, index + 1, target)):
                return True
            buckets[i] -= nums[index]
        return False
        
#针对篮子选取数字
class Solution:
    def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:
        nums_sum = sum(nums)
        if nums_sum % k != 0:
            return False
        if k > len(nums):
            return False
        target = nums_sum // k
        nums.sort(reverse = True)
        visited = set()
        return self.dfs(nums, target, k, visited, 0, 0)
    def dfs(self, nums, target, k, visited, current_sum, next_index):
    #还剩下一个的时候和必定为target，所以就不用算了
        if k == 1:
            return True
        #一个篮子满足了，开始算下一个篮子，数字开始选取的index又变回了0
        if current_sum == target:
            return self.dfs(nums, target, k - 1, visited, 0, 0)
        #因为下个dfs本质上还是在同一个篮子里操作，所以数字选取范围是越来越小的
        for i in range(next_index, len(nums)):
            if i in visited:
                continue 
            if nums[i] + current_sum > target:
                continue
            visited.add(i)
            current_sum += nums[i]
            if self.dfs(nums, target, k, visited, current_sum, next_index + 1):
                return True
            current_sum -= nums[i]
            visited.remove(i)
        return False
```

##### 11.29
###### Trie
[Leetcode 212. Word Search II](https://leetcode.com/problems/word-search-ii/)

利用trie剪枝的dfs。dfs的参数使用node，减少trie的查询次数。当一个word加入result后将这个word标记为非，可以避免重复结果。

```python
class Node:
    def __init__(self, key):
        self.key = key
        self.is_word = False
        self.children = {}
class Trie:
    def __init__(self):
        self.root = Node(0)
    def insert(self, word):
        current = self.root
        for char in word:
            if char not in current.children:
                current.children[char] = Node(char)
            current = current.children[char]
        current.is_word = True
class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        trie = Trie()
        for word in words:
            trie.insert(word)
        current_node = trie.root
        m = len(board)
        n = len(board[0])
        result = []
        for i in range(m):
            for j in range(n):
                self.dfs(board, i, j, current_node, "", result)
        return result
    def dfs(self, board, i, j, current_node, path, result):
        if current_node.is_word:
            result.append(path)
            current_node.is_word = False
        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]):
            return 
        tmp = board[i][j]
        if tmp not in current_node.children:
            return 
        current_node = current_node.children[tmp]
        board[i][j] = "#"
        self.dfs(board, i + 1, j, current_node, path + tmp, result)
        self.dfs(board, i - 1, j, current_node, path + tmp, result)
        self.dfs(board, i, j + 1, current_node, path + tmp, result)
        self.dfs(board, i, j - 1, current_node, path + tmp, result)
        board[i][j] = tmp
        
```